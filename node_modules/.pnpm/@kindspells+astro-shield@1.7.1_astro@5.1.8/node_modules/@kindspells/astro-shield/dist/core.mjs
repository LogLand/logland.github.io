var ue = Object.defineProperty;
var k = (t, e) => ue(t, "name", { value: e, configurable: !0 });
import { createHash as fe } from "node:crypto";
import { stat as K, readdir as V, writeFile as W, readFile as M, mkdir as ge } from "node:fs/promises";
import { resolve as O, relative as Z, extname as B, dirname as ye } from "node:path";
import { fileURLToPath as Q } from "node:url";
var we = Object.defineProperty, X = /* @__PURE__ */ k((t, e) => we(t, "name", { value: e, configurable: !0 }), "o$1");
const A = /* @__PURE__ */ X(async (t) => {
  try {
    return await K(t), !0;
  } catch (e) {
    if (e?.code === "ENOENT")
      return !1;
    throw e;
  }
}, "doesFileExist"), T = /* @__PURE__ */ X(async (t, e, s, i, r, n, a, o) => {
  for (const l of await V(e)) {
    const c = O(e, l), m = await K(c);
    m.isDirectory() ? await T(
      t,
      c,
      s,
      i,
      r,
      n,
      a,
      o
    ) : m.isFile() && n(l) && await r(t, c, s, i, a, o);
  }
}, "scanDirectory");
var me = Object.defineProperty, j = /* @__PURE__ */ k((t, e) => me(t, "name", { value: e, configurable: !0 }), "r");
const Se = /* @__PURE__ */ j((t) => Array.from(t).sort().map((e) => `'${e}'`).join(" "), "serialiseHashes"), $e = /* @__PURE__ */ j((t) => Array.from(t).sort().join(" "), "serializeCspDirectiveSources"), U = /* @__PURE__ */ j((t) => Object.entries(t).sort().map(([e, s]) => `${e} ${s}`).join("; "), "serialiseCspDirectives"), E = /* @__PURE__ */ j((t, e, s) => {
  const i = t[e];
  if (i) {
    const r = new Set(i.split(ee));
    for (const n of s)
      r.add(`'${n}'`);
    t[e] = $e(r);
  } else
    t[e] = `'self' ${Se(s)}`;
}, "setSrcDirective"), He = /;\s*/i, ee = /\s+/i, ve = /* @__PURE__ */ j((t) => t ? Object.fromEntries(
  t.split(He).filter((e) => !!e).map((e) => {
    const s = e.replace(ee, "||||||").split("||||||");
    return [s[0], s[1] ?? ""];
  }) ?? []
) : {}, "parseCspDirectives"), be = /* @__PURE__ */ j((t, e, s) => {
  const i = Object.hasOwn(t, "content-security-policy") ? {
    ...s.cspDirectives,
    ...ve(
      t["content-security-policy"]
    )
  } : s.cspDirectives ?? {};
  e.scripts.size > 0 ? E(i, "script-src", e.scripts) : i["script-src"] = "'none'", e.styles.size > 0 ? E(i, "style-src", e.styles) : i["style-src"] = "'none'", Object.keys(i).length > 0 && (t["content-security-policy"] = U(i));
}, "patchCspHeader"), xe = /* @__PURE__ */ j((t, e, s) => {
  const i = Object.fromEntries(t.entries());
  return s.contentSecurityPolicy !== void 0 && be(
    i,
    e,
    s.contentSecurityPolicy
  ), new Headers(i);
}, "patchHeaders");
var Re = Object.defineProperty, S = /* @__PURE__ */ k((t, e) => Re(t, "name", { value: e, configurable: !0 }), "d$2");
const te = /^\s+/, ke = /^(?<indent>\s*)(?<name>([a-zA-Z0-9_\-]+)):\s*(?<value>.*)$/i, Ce = /^(?<indent>\s*)(?<comment>#.*)$/i, _ = /* @__PURE__ */ S((t, e, s) => {
  if (e === "")
    s.entries.push(e);
  else if (e.startsWith("#"))
    s.entries.push({ comment: e });
  else {
    if (te.test(e))
      throw new Error(`Unexpected indentation (line ${t})`);
    if (e.startsWith("/"))
      s.currentPath = { path: e, entries: [] }, s.entries.push(s.currentPath);
    else
      throw new Error(`Bad syntax (line ${t})`);
  }
}, "tryToInitializePathConfig"), je = /* @__PURE__ */ S((t, e, s) => {
  if (e.groups?.comment === void 0)
    throw new Error(`Bad syntax (line ${t})`);
  s?.entries.push({ comment: e.groups.comment });
}, "pushComment"), Pe = /* @__PURE__ */ S((t, e, s) => {
  if (e.groups?.name === void 0 || e.groups?.value === void 0)
    throw new Error(`Bad syntax (line ${t})`);
  s?.entries.push({
    key: e.groups.name,
    value: e.groups.value
  });
}, "pushHeader"), J = /* @__PURE__ */ S((t, e, s, i, r) => {
  if (r.indentWith === void 0) {
    if (t.groups?.indent === void 0)
      throw new Error(`Bad syntax (line ${e})`);
    if (t.groups?.indent === "")
      throw new Error(`Unable to infer indentation (line ${e})`);
    r.indentWith = t.groups?.indent;
  }
  if (t.groups?.indent === "") {
    if ((r.currentPath?.entries.length ?? 0) === 0)
      throw new Error(`Bad syntax (line ${e})`);
    r.currentPath = void 0, _(e, s, r);
  } else {
    if (t.groups?.indent !== r.indentWith)
      throw new Error(`Unexpected indentation (line ${e})`);
    i(e, t, r.currentPath);
  }
}, "pushEntry"), Oe = /* @__PURE__ */ S((t, e, s) => {
  let i = null;
  if (i = Ce.exec(e))
    J(i, t, e, je, s);
  else if (i = ke.exec(e))
    J(i, t, e, Pe, s);
  else if (!te.test(e)) {
    if ((s.currentPath?.entries.length ?? 0) === 0)
      throw new Error(`Bad syntax (line ${t})`);
    s.currentPath = void 0, _(t, e, s);
  }
}, "processPathLine"), Me = /* @__PURE__ */ S((t) => {
  const e = {
    indentWith: void 0,
    entries: [],
    currentPath: void 0
  };
  for (const [s, i] of t.split(`
`).entries())
    e.currentPath === void 0 ? _(s, i, e) : Oe(s, i, e);
  return {
    indentWith: e.indentWith ?? "	",
    entries: e.entries.at(-1) === "" ? e.entries.slice(0, -1) : e.entries
  };
}, "parseNetlifyHeadersConfig"), Ee = /* @__PURE__ */ S(async (t) => Me(await M(t, "utf8")), "readNetlifyHeadersFile"), ze = /* @__PURE__ */ S((t) => {
  const e = t.indentWith;
  let s = "";
  for (const i of t.entries)
    i === "" ? s += `
` : "comment" in i ? s += `${i.comment}
` : "path" in i && (s += `${i.path}
${i.entries.map(
      (r) => "comment" in r ? `${e}${r.comment}` : `${e}${r.key}: ${r.value}`
    ).join(`
`)}
`);
  return s;
}, "serializeNetlifyHeadersConfig"), F = /* @__PURE__ */ S((t, e) => t === "" || e === "" || "comment" in t || "comment" in e ? 0 : t.path < e.path ? -1 : t.path > e.path ? 1 : 0, "compareConfigEntries"), De = /* @__PURE__ */ S((t, e) => "comment" in t || "comment" in e ? 0 : t.key < e.key ? -1 : t.key > e.key ? 1 : t.value < e.value ? -1 : t.value > e.value ? 1 : 0, "comparePathEntries"), Ne = /* @__PURE__ */ S((t, e) => "comment" in t || "comment" in e ? 0 : t.key < e.key ? -1 : t.key > e.key ? 1 : 0, "comparePathEntriesSimplified"), Ae = /* @__PURE__ */ S((t, e) => {
  const s = {
    indentWith: "	",
    entries: []
  }, i = [];
  for (const [r, n] of e.entries())
    (r === "index.html" || r.endsWith("/index.html")) && i.push([r.slice(0, -10), n]), i.push([r, n]);
  i.sort();
  for (const [r, n] of i) {
    const a = [];
    if (t.contentSecurityPolicy !== void 0) {
      const o = t.contentSecurityPolicy.cspDirectives ?? {};
      if (n.scripts.size > 0 ? E(o, "script-src", n.scripts) : o["script-src"] = "'none'", n.styles.size > 0 ? E(o, "style-src", n.styles) : o["style-src"] = "'none'", Object.keys(o).length === 0)
        continue;
      a.push({
        key: "content-security-policy",
        value: U(o)
      });
    }
    a.length > 0 && s.entries.push({
      path: `/${r}`,
      entries: a.sort(De)
    });
  }
  return s;
}, "buildNetlifyHeadersConfig"), We = /* @__PURE__ */ S((t, e) => {
  const s = [];
  let i = 0, r = 0;
  for (; i < t.length && r < e.length; ) {
    const n = t[i], a = e[r];
    switch (Ne(n, a)) {
      case -1: {
        s.push(n), i += 1;
        break;
      }
      case 0: {
        "comment" in a ? r += 1 : "comment" in n ? (s.push(n), i += 1) : (s.push(a), i += 1, r += 1);
        break;
      }
      case 1: {
        s.push(a), r += 1;
        break;
      }
      default:
        throw new Error("Unreachable");
    }
  }
  for (; i < t.length; i += 1)
    s.push(t[i]);
  for (; r < e.length; r += 1)
    s.push(e[r]);
  return s;
}, "mergeNetlifyPathHeaders"), Ie = /* @__PURE__ */ S((t, e) => {
  const s = t.indentWith, i = t.entries.slice().sort(F), r = e.entries.slice().sort(F), n = [];
  let a = 0, o = 0;
  for (; a < i.length && o < r.length; ) {
    const l = i[a], c = r[o];
    switch (F(l, c)) {
      case -1: {
        typeof l == "object" && "entries" in l && l.entries.length === 0 || n.push(l), a += 1;
        break;
      }
      case 0: {
        if (c === "" || "comment" in c)
          o += 1;
        else if (l === "" || "comment" in l)
          n.push(c), o += 1;
        else if (l.path === c.path)
          n.push({
            path: l.path,
            entries: We(
              l.entries,
              c.entries
            )
          }), a += 1, o += 1;
        else
          throw new Error("Unreachable");
        break;
      }
      case 1: {
        typeof c == "object" && "entries" in c && c.entries.length === 0 || n.push(c), o += 1;
        break;
      }
      default:
        throw new Error("Unreachable");
    }
  }
  for (; a < i.length; a += 1)
    n.push(i[a]);
  for (; o < r.length; o += 1)
    n.push(r[o]);
  return {
    indentWith: s,
    entries: n
  };
}, "mergeNetlifyHeadersConfig"), Fe = /* @__PURE__ */ S(async (t, e, s) => {
  const i = await A(t) ? await Ee(t) : { indentWith: "	", entries: [] }, r = Ae(
    e,
    s
  ), n = Ie(i, r);
  await W(t, ze(n));
}, "patchNetlifyHeadersConfig");
var Ve = Object.defineProperty, Be = /* @__PURE__ */ k((t, e) => Ve(t, "name", { value: e, configurable: !0 }), "e");
const Te = /* @__PURE__ */ Be((t, e) => {
  throw new Error(`Unknown ${e}: ${t}`);
}, "exhaustiveGuard");
var Ue = Object.defineProperty, z = /* @__PURE__ */ k((t, e) => Ue(t, "name", { value: e, configurable: !0 }), "n");
const _e = /\.vercel\/output\/static\/?$/, Le = /* @__PURE__ */ z((t, e) => {
  const s = JSON.parse(e);
  if (!("version" in s))
    throw new Error('Invalid Vercel config: missing "version" field');
  return s.version !== 3 && t.warn(
    `Expected Vercel config version 3, but got version ${s.version}`
  ), s;
}, "parseVercelConfig"), qe = /* @__PURE__ */ z(async (t, e) => Le(t, await M(e, "utf8")), "readVercelConfigFile"), Ge = /* @__PURE__ */ z((t, e, s) => {
  const i = t.trailingSlash === "never" ? -11 : t.trailingSlash === "always" ? -10 : void 0, r = [];
  for (const [a, o] of s.entries())
    i !== void 0 && (a === "index.html" || a.endsWith("/index.html")) && r.push([a.slice(0, i), o]), r.push([a, o]);
  r.sort();
  const n = [];
  for (const [a, o] of r) {
    const l = {};
    if (e.contentSecurityPolicy !== void 0) {
      const c = e.contentSecurityPolicy.cspDirectives ?? {};
      if (o.scripts.size > 0 ? E(c, "script-src", o.scripts) : c["script-src"] = "'none'", o.styles.size > 0 ? E(c, "style-src", o.styles) : c["style-src"] = "'none'", Object.keys(c).length === 0)
        continue;
      l["content-security-policy"] = U(c);
    }
    Object.keys(l).length > 0 && n.push({
      src: `^/${a.replaceAll(".", "\\.")}$`,
      headers: l,
      continue: !0
    });
  }
  return { version: 3, routes: n };
}, "buildVercelConfig"), Je = /* @__PURE__ */ z((t, e) => ({ ...t, routes: [...e.routes ?? [], ...t.routes ?? []] }), "mergeVercelConfig"), Ye = /* @__PURE__ */ z((t) => JSON.stringify(t, null, "	"), "serializeVercelConfig"), Ke = /* @__PURE__ */ z(async (t, e, s, i, r) => {
  if (!_e.test(e)) {
    t.warn(
      '"@astrojs/vercel/static" adapter not detected, but "securityHeaders.enableOnStaticPages.provider" is set to "vercel". See https://docs.astro.build/en/guides/integrations-guide/vercel/#choosing-a-target to learn how to set up the adapter.'
    );
    return;
  }
  const n = O(e, "..", "config.json");
  if (!await A(n)) {
    t.error(
      `Vercel adapter detected, but "config.json" not found in "${n}".`
    ), t.error(JSON.stringify(await V(O(e)))), t.error(JSON.stringify(await V(O(e, ".."))));
    return;
  }
  const a = await qe(t, n), o = Ge(
    s,
    i,
    r
  ), l = Je(a, o);
  await W(n, Ye(l));
}, "patchVercelHeadersConfig");
var Ze = Object.defineProperty, u = /* @__PURE__ */ k((t, e) => Ze(t, "name", { value: e, configurable: !0 }), "d");
const C = /* @__PURE__ */ u((t) => {
  const e = fe("sha256");
  return t instanceof ArrayBuffer ? e.update(Buffer.from(t)) : t instanceof Buffer ? e.update(t) : e.update(t, "utf8"), `sha256-${e.digest("base64")}`;
}, "generateSRIHash"), Qe = /* @__PURE__ */ u((t, e, s, i) => `<script${e} integrity="${t}"${s ? ' crossorigin="anonymous"' : ""}>${i ?? ""}<\/script>`, "scriptReplacer"), Xe = /* @__PURE__ */ u((t, e, s, i) => `<style${e} integrity="${t}"${s ? ' crossorigin="anonymous"' : ""}>${i ?? ""}</style>`, "styleReplacer"), et = /* @__PURE__ */ u((t, e, s) => `<link${e} integrity="${t}"${s ? ' crossorigin="anonymous"' : ""}/>`, "linkStyleReplacer"), se = /^(https?:)?\/\/[^/]/i, re = /crossorigin\s*=\s*("anonymous"|'anonymous'|anonymous)/i, tt = /^integrity\s*=\s*("(?<integrity1>sha256-[a-z0-9+\/]{43}=)"|'(?<integrity2>sha256-[a-z0-9+\/]{43}=)')$/i, st = /(^|\s+)rel\s*=\s*('stylesheet'|"stylesheet"|stylesheet(\s+?|$))/i, rt = /(?<!=)\s+(?!=)/, ie = /* @__PURE__ */ u((t) => {
  for (const e of t.split(rt))
    if (e.length <= 128) {
      const s = tt.exec(e);
      if (s)
        return s.groups?.integrity1 ?? s.groups?.integrity2;
    }
}, "extractIntegrityHash"), ne = [
  {
    t: "Script",
    t2: "scripts",
    regex: /<script(?<attrs>(\s+[a-z][a-z0-9\-_]*(\s*=\s*('[^']*'|"[^"]*"|[a-z0-9\-_\/\.]+))?)*?)\s*>(?<content>[\s\S]*?)<\/\s*script((?<closingTrick>(\s+[a-z][a-z0-9\-_]*(\s*=\s*('[^']*'|"[^"]*"|[a-z0-9\-_]+))?)+?)|\s*>)/gi,
    srcRegex: /(^|\s+)src\s*=\s*("(?<src1>[^"]*)"|'(?<src2>[^']*)'|(?<src3>[a-z0-9\-_\/\.]+))/i,
    replacer: Qe,
    hasContent: !0,
    attrsRegex: void 0
  },
  {
    t: "Style",
    t2: "styles",
    regex: /<style(?<attrs>(\s+[a-z][a-z0-9\-_]*(\s*=\s*('[^']*'|"[^"]*"|[a-z0-9\-_\/\.]+))?)*?)\s*>(?<content>[\s\S]*?)<\/\s*style((?<closingTrick>(\s+[a-z][a-z0-9\-_]*(\s*=\s*('[^']*'|"[^"]*"|[a-z0-9\-_]+))?)+?)|\s*>)/gi,
    srcRegex: /(^|\s+)(href|src)\s*=\s*("(?<src1>[^"]*)"|'(?<src2>[^']*)'|(?<src3>[a-z0-9\-_\/\.]+))/i,
    // not really used
    replacer: Xe,
    hasContent: !0,
    attrsRegex: void 0
  },
  {
    t: "Style",
    t2: "styles",
    regex: /<link(?<attrs>(\s+[a-z][a-z0-9\-_]*(\s*=\s*('[^']*'|"[^"]*"|[a-z0-9\-_\/\.]+))?)*?)\s*\/?>/gi,
    srcRegex: /(^|\s+)href\s*=\s*("(?<src1>[^"]*)"|'(?<src2>[^']*)'|(?<src3>[a-z0-9\-_\/\.]+))/i,
    replacer: et,
    hasContent: !1,
    attrsRegex: st
  }
], it = /* @__PURE__ */ u(async (t, e, s, i, r, n = "all", a = "all", o) => {
  const l = r.perPageSriHashes.get(s) ?? {
    scripts: /* @__PURE__ */ new Set(),
    styles: /* @__PURE__ */ new Set()
  };
  r.perPageSriHashes.set(s, l);
  let c = i, m;
  for (const {
    attrsRegex: H,
    hasContent: h,
    regex: p,
    srcRegex: y,
    replacer: x,
    t: $,
    t2: d
  } of ne)
    for (p.lastIndex = 0; (m = p.exec(i)) !== null; ) {
      const v = m.groups?.attrs?.trim() ?? "", R = m.groups?.content ?? "", f = R.trim() === "" ? "" : R;
      let g, D = !1;
      if (v) {
        if (H && !H.test(v))
          continue;
        const P = y.exec(v), w = P?.groups?.src1 ?? P?.groups?.src2 ?? P?.groups?.src3 ?? "";
        if (f && w) {
          t.warn(
            `${$} "${w}" must have either a src/href attribute or content, but not both. Removing it.`
          ), c = c.replace(m[0], "");
          continue;
        }
        const N = ie(v);
        if (N !== void 0) {
          N ? ((P ? r[`ext${$}Hashes`] : r[`inline${$}Hashes`]).add(
            N
          ), l[d].add(N), w && r.perResourceSriHashes[d].set(w, N)) : t.warn(
            `Found empty integrity attribute in "${s}".`
          );
          continue;
        }
        if (w) {
          const q = r.perResourceSriHashes[d].get(w);
          if (q)
            g = q, r[`ext${$}Hashes`].add(g), l[d].add(g);
          else {
            let I;
            if (se.test(w))
              D = !0, I = await (await fetch(
                w.startsWith("//") ? `https:${w}` : w,
                { method: "GET" }
              )).arrayBuffer();
            else if (w.startsWith("/")) {
              const G = o?.config.base ?? "", he = w.startsWith(G) ? w.replace(G, "") : w, de = O(e, `.${he}`);
              I = await M(de);
            } else {
              t.warn(`Unable to process external resource: "${w}"`);
              continue;
            }
            g = C(I), r[`ext${$}Hashes`].add(g), l[d].add(g), r.perResourceSriHashes[d].set(w, g);
          }
        }
      }
      if (h && !g)
        if (!(n === !1 && $ === "Script") && !(a === !1 && $ === "Style"))
          g = C(f), r[`inline${$}Hashes`].add(g), l[d].add(g);
        else {
          t.warn(
            `Removing inline ${$.toLowerCase()} block (inline ${d} are disabled).`
          ), c = c.replace(m[0], "");
          continue;
        }
      if (g) {
        const P = re.test(v);
        c = c.replace(
          m[0],
          x(
            g,
            v ? ` ${v}` : "",
            D && !P,
            f
          )
        );
      }
    }
  return c;
}, "updateStaticPageSriHashes"), ae = /* @__PURE__ */ u((t, e, s, i) => {
  let r = e, n;
  const a = {
    scripts: /* @__PURE__ */ new Set(),
    styles: /* @__PURE__ */ new Set()
  };
  for (const {
    attrsRegex: o,
    hasContent: l,
    regex: c,
    srcRegex: m,
    replacer: H,
    t: h,
    t2: p
  } of ne)
    for (c.lastIndex = 0; (n = c.exec(e)) !== null; ) {
      const y = n.groups?.attrs?.trim() ?? "", x = n.groups?.content ?? "", $ = x.trim() === "" ? "" : x;
      let d, v = !1;
      if (y) {
        if (o && !o.test(y))
          continue;
        const R = m.exec(y), f = R?.groups?.src1 ?? R?.groups?.src2 ?? R?.groups?.src3;
        if ($ && f) {
          t.warn(
            `${h} "${f}" must have either a src/href attribute or content, but not both. Removing it.`
          ), r = r.replace(n[0], "");
          continue;
        }
        const g = ie(y);
        if (g !== void 0) {
          if (g)
            if (f) {
              const D = s[p].get(f);
              D ? D !== g ? (t.warn(
                `Detected integrity hash mismatch for resource "${f}". Removing it.`
              ), r = r.replace(n[0], "")) : (d = g, a[p].add(d)) : (t.warn(
                `Detected reference to not explicitly allowed external resource "${f}". Removing it.`
              ), r = r.replace(n[0], ""));
            } else $ && (p === "scripts" && (i?.allowInlineScripts ?? "all") === "all" || p === "styles" && (i?.allowInlineStyles ?? "all") === "all" ? (d = g, a[p].add(d)) : (t.warn(
              `Removing inline ${h.toLowerCase()} block (inline ${p} are disabled).`
            ), r = r.replace(n[0], "")));
          else
            t.warn(
              `Found empty integrity attribute, removing inline ${h.toLowerCase()} block.`
            ), r = r.replace(n[0], "");
          continue;
        }
        if (f)
          if (se.test(f))
            if (v = !0, d = s[p].get(f), d)
              a[p].add(d);
            else {
              t.warn(
                `Detected reference to not explicitly allowed external resource "${f}". Removing it.`
              ), r = r.replace(n[0], "");
              continue;
            }
          else if (f.startsWith("/"))
            if (d = s[p].get(f), d)
              a[p].add(d);
            else {
              f.startsWith("/@vite/") || f.startsWith("/@fs/") || f.indexOf("?astro&type=") >= 0 || t.warn(
                `Unable to obtain SRI hash for local resource: "${f}"`
              );
              continue;
            }
          else {
            t.warn(`Unable to process external resource: "${f}".`);
            continue;
          }
      }
      if (l && !d)
        if ((i?.allowInlineScripts ?? "all") === "all" && h === "Script" || (i?.allowInlineStyles ?? "all") === "all" && h === "Style")
          d = C($), a[p].add(d);
        else {
          t.warn(
            `Removing inline ${h.toLowerCase()} block (inline ${p} are disabled)`
          ), r = r.replace(n[0], "");
          continue;
        }
      if (d) {
        const R = re.test(y);
        r = r.replace(
          n[0],
          H(
            d,
            y ? ` ${y}` : "",
            v && !R,
            $
          )
        );
      }
    }
  return {
    pageHashes: a,
    updatedContent: r
  };
}, "updateDynamicPageSriHashes"), nt = /* @__PURE__ */ u(async (t, e, s, i, r, n) => {
  const a = await M(e, "utf8"), o = await it(
    t,
    s,
    Z(s, e),
    a,
    i,
    r?.allowInlineScripts ?? "all",
    r?.allowInlineStyles ?? "all",
    n
  );
  o !== a && await W(e, o);
}, "processHTMLFile"), b = /* @__PURE__ */ u((t, e) => {
  if (t.length !== e.length)
    return !1;
  for (let s = 0; s < t.length; s++)
    if (t[s] !== e[s])
      return !1;
  return !0;
}, "arraysEqual"), at = /* @__PURE__ */ u((t, e) => {
  const s = Object.keys(t).sort(), i = Object.keys(e).sort();
  if (!b(s, i))
    return !1;
  for (const [r, n] of Object.entries(t)) {
    const a = e[r];
    if (!a || !b(n.scripts, a.scripts) || !b(n.styles, a.styles))
      return !1;
  }
  return !0;
}, "pageHashesEqual"), ot = /* @__PURE__ */ u((t, e) => {
  const s = Object.keys(t.scripts).sort(), i = Object.keys(e.scripts).sort(), r = Object.keys(t.styles).sort(), n = Object.keys(e.styles).sort();
  if (!b(s, i) || !b(r, n))
    return !1;
  for (const [a, o] of Object.entries(t.scripts))
    if (e.scripts[a] !== o)
      return !1;
  for (const [a, o] of Object.entries(t.styles))
    if (e.styles[a] !== o)
      return !1;
  return !0;
}, "sriHashesEqual"), oe = /* @__PURE__ */ u(async (t, e, s) => {
  await T(
    t,
    e,
    e,
    s,
    async (i, r, n, a) => {
      const o = `/${Z(n, r)}`, l = B(r);
      if ([".js", ".mjs"].includes(l)) {
        if (!a.perResourceSriHashes.scripts.has(o)) {
          const c = C(await M(r));
          a.extScriptHashes.add(c), a.perResourceSriHashes.scripts.set(o, c);
        }
      } else if (l === ".css" && !a.perResourceSriHashes.styles.has(o)) {
        const c = C(await M(r));
        a.extStyleHashes.add(c), a.perResourceSriHashes.styles.set(o, c);
      }
    },
    (i) => [".js", ".mjs", ".css"].includes(B(i))
  );
}, "scanForNestedResources"), ce = /* @__PURE__ */ u(async (t, e) => {
  for (const s of t.scriptsAllowListUrls ?? []) {
    const i = await (await fetch(s, { method: "GET" })).arrayBuffer(), r = C(i);
    e.extScriptHashes.add(r), e.perResourceSriHashes.scripts.set(s, r);
  }
  for (const s of t.stylesAllowListUrls ?? []) {
    const i = await (await fetch(s, { method: "GET" })).arrayBuffer(), r = C(i);
    e.extStyleHashes.add(r), e.perResourceSriHashes.styles.set(s, r);
  }
}, "scanAllowLists");
async function L(t, e, s, i) {
  let r = !1, n = !1;
  const a = Array.from(e.inlineScriptHashes).sort(), o = Array.from(e.inlineStyleHashes).sort(), l = Array.from(e.extScriptHashes).sort(), c = Array.from(e.extStyleHashes).sort(), m = {};
  for (const [h, p] of e.perPageSriHashes.entries())
    m[h] = {
      scripts: Array.from(p.scripts).sort(),
      styles: Array.from(p.styles).sort()
    };
  const H = { scripts: {}, styles: {} };
  for (const [h, p] of e.perResourceSriHashes.scripts.entries())
    H.scripts[h] = p;
  for (const [h, p] of e.perResourceSriHashes.styles.entries())
    H.styles[h] = p;
  if (await A(s)) {
    const h = await import(
      /* @vite-ignore */
      s
    );
    r = !ot(
      H,
      h.perResourceSriHashes ?? { scripts: {}, styles: {} }
    ), n = r || !b(a, h.inlineScriptHashes ?? []) || !b(o, h.inlineStyleHashes ?? []) || !b(l, h.extScriptHashes ?? []) || !b(c, h.extStyleHashes ?? []) || !at(m, h.perPageSriHashes ?? {});
  } else
    n = !0;
  if (n) {
    r && i && t.warn(
      "SRI hashes have changed for static resources that may be used in dynamic pages. You should run the build step again"
    );
    let h = `// Do not edit this file manually

`;
    h += `export const inlineScriptHashes = /** @type {string[]} */ ([${a.map((p) => `
	'${p}',`).join("")}${a.length > 0 ? `
` : ""}])

`, h += `export const inlineStyleHashes = /** @type {string[]} */ ([${o.map((p) => `
	'${p}',`).join("")}${o.length > 0 ? `
` : ""}])

`, h += `export const extScriptHashes = /** @type {string[]} */ ([${l.map((p) => `
	'${p}',`).join("")}${l.length > 0 ? `
` : ""}])

`, h += `export const extStyleHashes = /** @type {string[]} */ ([${c.map((p) => `
	'${p}',`).join("")}${c.length > 0 ? `
` : ""}])

`, h += `export const perPageSriHashes =
	/** @type {Record<string, { scripts: string[]; styles: string [] }>} */ ({${Object.entries(
      m
    ).sort().map(
      ([p, y]) => `
		'${p}': {
			scripts: [${y.scripts.map((x) => `
				'${x}',`).join("")}${y.scripts.length > 0 ? `
			` : ""}],
			styles: [${y.styles.map((x) => `
				'${x}',`).join("")}${y.styles.length > 0 ? `
			` : ""}],
		}`
    ).join(",")}}
)

`, h += `export const perResourceSriHashes = {
	scripts: /** @type {Record<string,string>} */ ({
${Object.entries(
      H.scripts
    ).map(([p, y]) => `		'${p}': '${y}',
`).join(
      ""
    )}	}),
	styles: /** @type {Record<string,string>} */ ({
${Object.entries(
      H.styles
    ).map(([p, y]) => `		'${p}': '${y}',
`).join("")}	}),
}
`, await ge(ye(s), { recursive: !0 }), await W(s, h);
  }
}
k(L, "generateSRIHashesModule");
u(L, "generateSRIHashesModule");
const le = /* @__PURE__ */ u(() => ({
  inlineScriptHashes: /* @__PURE__ */ new Set(),
  inlineStyleHashes: /* @__PURE__ */ new Set(),
  extScriptHashes: /* @__PURE__ */ new Set(),
  extStyleHashes: /* @__PURE__ */ new Set(),
  perPageSriHashes: /* @__PURE__ */ new Map(),
  perResourceSriHashes: {
    scripts: /* @__PURE__ */ new Map(),
    styles: /* @__PURE__ */ new Map()
  }
}), "newHashesCollection"), ct = /* @__PURE__ */ u(async (t, { state: e, distDir: s, sri: i, securityHeaders: r }) => {
  const n = le();
  if (await ce(i, n), await oe(t, s, n), await T(
    t,
    s,
    s,
    n,
    nt,
    (a) => B(a) === ".html",
    i,
    e
  ), r?.enableOnStaticPages !== void 0) {
    const a = r.enableOnStaticPages.provider;
    switch (a) {
      case "netlify": {
        await Fe(
          O(s, "_headers"),
          r,
          n.perPageSriHashes
        );
        break;
      }
      case "vercel": {
        await Ke(
          t,
          s,
          e.config,
          r,
          n.perPageSriHashes
        );
        break;
      }
      default:
        Te(a, "provider");
    }
  }
  i.hashesModule && await L(
    t,
    n,
    i.hashesModule,
    i.enableMiddleware
  );
}, "processStaticFiles"), wt = /* @__PURE__ */ u((t, e, s) => async (i, r) => {
  const n = await r(), a = await n.text(), { updatedContent: o } = ae(
    t,
    a,
    e,
    s
  );
  return new Response(o, {
    status: n.status,
    statusText: n.statusText,
    headers: n.headers
  });
}, "getMiddlewareHandler"), mt = /* @__PURE__ */ u((t, e, s, i) => async (r, n) => {
  const a = await n(), o = await a.text(), { updatedContent: l, pageHashes: c } = ae(
    t,
    o,
    e,
    i
  );
  return new Response(l, {
    status: a.status,
    statusText: a.statusText,
    headers: xe(a.headers, c, s)
  });
}, "getCSPMiddlewareHandler"), pe = "virtual:@kindspells/astro-shield/middleware", Y = `\0${pe}`, lt = /* @__PURE__ */ u(async (t, e, s, i) => {
  let r = "", n = "";
  if (e.enableStatic && e.hashesModule) {
    let a = !await A(e.hashesModule);
    if (!a)
      try {
        const o = await import(
          /* @vite-ignore */
          e.hashesModule
        );
        for (const l of e.scriptsAllowListUrls)
          if (!Object.hasOwn(
            o.perResourceSriHashes.scripts,
            l
          )) {
            a = !0;
            break;
          }
      } catch (o) {
        t.warn(
          `Failed to load SRI hashes module "${e.hashesModule}", it will be re-generated:
	${o}`
        ), a = !0;
      }
    if (a) {
      const o = le();
      await oe(t, i, o), await ce(e, o), await L(
        t,
        o,
        e.hashesModule,
        !1
        // So we don't get redundant warnings
      );
    }
  }
  return e.enableStatic && e.hashesModule && await A(e.hashesModule) ? (r = `import { perResourceSriHashes } from '${e.hashesModule}'`, n = `
try {
	if (perResourceSriHashes) {
		for (const [key, value] of Object.entries(
			perResourceSriHashes.scripts ?? {},
		)) {
			globalHashes.scripts.set(key, value)
		}
		for (const [key, value] of Object.entries(
			perResourceSriHashes.styles ?? {},
		)) {
			globalHashes.styles.set(key, value)
		}
	}
} catch (err) {
	console.error('Failed to load static hashes module:', err)
}
`) : e.enableStatic && e.hashesModule && t.warn(
    `The SRI hashes module "${e.hashesModule}" did not exist at build time. You may have to run the build step again`
  ), `
import { defineMiddleware } from 'astro/middleware'
import { getGlobalHashes } from '@kindspells/astro-shield/state'
import { ${s !== void 0 ? "getCSPMiddlewareHandler" : "getMiddlewareHandler"} } from '@kindspells/astro-shield/core'
${r}

export const onRequest = await (async () => {
	const globalHashes = await getGlobalHashes()

	${n}

	return defineMiddleware(${s !== void 0 ? `getCSPMiddlewareHandler(console, globalHashes, ${JSON.stringify(
    s
  )}, ${JSON.stringify(e)})` : `getMiddlewareHandler(console, globalHashes, ${JSON.stringify(e)})`})
})()
`;
}, "loadVirtualMiddlewareModule"), pt = /* @__PURE__ */ u((t, e, s, i) => ({
  name: "vite-plugin-astro-shield",
  resolveId(r) {
    if (r === pe)
      return Y;
  },
  async load(r, n) {
    switch (r) {
      case Y:
        return await lt(
          t,
          e,
          s,
          i
        );
      default:
        return;
    }
  }
}), "getViteMiddlewarePlugin"), ht = /* @__PURE__ */ u((t, e, s) => async ({ dir: i, logger: r }) => {
  e.enableStatic && await ct(r, {
    state: t,
    distDir: Q(i),
    sri: e,
    securityHeaders: s
  });
}, "getAstroBuildDone"), St = /* @__PURE__ */ u((t, e, s) => async ({ logger: i, addMiddleware: r, config: n, updateConfig: a }) => {
  if (t.config = n, e.enableMiddleware) {
    const o = Q(n.publicDir), l = pt(
      i,
      e,
      s,
      o
    );
    a({ vite: { plugins: [l] } }), r({
      order: "post",
      entrypoint: "virtual:@kindspells/astro-shield/middleware"
    });
  }
  t.delayTransform && a({
    integrations: [
      {
        name: "@kindspells/astro-shield-post-config-setup",
        hooks: {
          "astro:build:done": ht(
            t,
            e,
            s
          )
        }
      }
    ]
  });
}, "getAstroConfigSetup");
export {
  b as arraysEqual,
  C as generateSRIHash,
  L as generateSRIHashesModule,
  ht as getAstroBuildDone,
  St as getAstroConfigSetup,
  mt as getCSPMiddlewareHandler,
  wt as getMiddlewareHandler,
  pt as getViteMiddlewarePlugin,
  at as pageHashesEqual,
  ct as processStaticFiles,
  ne as regexProcessors,
  ce as scanAllowLists,
  oe as scanForNestedResources,
  ot as sriHashesEqual,
  ae as updateDynamicPageSriHashes,
  it as updateStaticPageSriHashes
};
//# sourceMappingURL=core.mjs.map
