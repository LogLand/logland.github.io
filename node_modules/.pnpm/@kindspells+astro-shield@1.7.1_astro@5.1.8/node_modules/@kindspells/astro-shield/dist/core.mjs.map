{"version":3,"file":"core.mjs","sources":["../src/fs.mts","../src/headers.mts","../src/netlify.mts","../src/utils.mts","../src/vercel.mts","../src/core.mts"],"sourcesContent":["/*\n * SPDX-FileCopyrightText: 2024 KindSpells Labs S.L.\n *\n * SPDX-License-Identifier: MIT\n */\n\nimport { readdir, stat } from 'node:fs/promises'\nimport { resolve } from 'node:path'\n\nimport type {\n\tHashesCollection,\n\tIntegrationState,\n\tLogger,\n\tSRIOptions,\n} from './types.mts'\n\n/** @internal */\nexport const doesFileExist = async (path: string): Promise<boolean> => {\n\ttry {\n\t\tawait stat(path)\n\t\treturn true\n\t} catch (err) {\n\t\tif ((err as undefined | { code: unknown })?.code === 'ENOENT') {\n\t\t\treturn false\n\t\t}\n\t\tthrow err\n\t}\n}\n\n/** @internal */\nexport const scanDirectory = async (\n\tlogger: Logger,\n\tcurrentPath: string,\n\trootPath: string,\n\th: HashesCollection,\n\tprocessFile: (\n\t\tlogger: Logger,\n\t\tfilePath: string,\n\t\tdistDir: string,\n\t\th: HashesCollection,\n\t\tsri?: SRIOptions,\n\t\tstate?: IntegrationState,\n\t) => Promise<void>,\n\tfilenameCondition: (filename: string) => boolean,\n\tsri?: SRIOptions,\n\tstate?: IntegrationState,\n): Promise<void> => {\n\tfor (const file of await readdir(currentPath)) {\n\t\tconst filePath = resolve(currentPath, file)\n\t\tconst stats = await stat(filePath)\n\n\t\tif (stats.isDirectory()) {\n\t\t\tawait scanDirectory(\n\t\t\t\tlogger,\n\t\t\t\tfilePath,\n\t\t\t\trootPath,\n\t\t\t\th,\n\t\t\t\tprocessFile,\n\t\t\t\tfilenameCondition,\n\t\t\t\tsri,\n\t\t\t\tstate,\n\t\t\t)\n\t\t} else if (stats.isFile() && filenameCondition(file)) {\n\t\t\tawait processFile(logger, filePath, rootPath, h, sri, state)\n\t\t}\n\t}\n}\n","import type { CSPDirectiveNames, PerPageHashes } from './types.mts'\nimport type {\n\tCSPDirectives,\n\tCSPOptions,\n\tSecurityHeadersOptions,\n} from './types.mts'\n\nexport const serialiseHashes = (hashes: Set<string>): string =>\n\tArray.from(hashes)\n\t\t.sort()\n\t\t.map(h => `'${h}'`)\n\t\t.join(' ')\n\nexport const serializeCspDirectiveSources = (hashes: Set<string>): string =>\n\tArray.from(hashes).sort().join(' ')\n\nexport const serialiseCspDirectives = (directives: CSPDirectives): string =>\n\tObject.entries(directives)\n\t\t.sort()\n\t\t.map(([k, v]) => `${k} ${v}`)\n\t\t.join('; ')\n\nexport const setSrcDirective = (\n\tdirectives: CSPDirectives,\n\tsrcType: 'script-src' | 'style-src',\n\thashes: Set<string>,\n): void => {\n\tconst baseSrcDirective = directives[srcType]\n\tif (baseSrcDirective) {\n\t\tconst srcDirective = new Set(baseSrcDirective.split(spacesRegex))\n\t\tfor (const hash of hashes) {\n\t\t\tsrcDirective.add(`'${hash}'`)\n\t\t}\n\t\tdirectives[srcType] = serializeCspDirectiveSources(srcDirective)\n\t} else {\n\t\tdirectives[srcType] = `'self' ${serialiseHashes(hashes)}`\n\t}\n}\n\nconst cspSplitterRegex = /;\\s*/i\nconst spacesRegex = /\\s+/i\n\nexport const parseCspDirectives = (cspHeader: string): CSPDirectives => {\n\treturn cspHeader\n\t\t? Object.fromEntries(\n\t\t\t\tcspHeader\n\t\t\t\t\t.split(cspSplitterRegex)\n\t\t\t\t\t.filter(v => !!v)\n\t\t\t\t\t.map(directive => {\n\t\t\t\t\t\t// This is a hack to split the directive into _only_ two parts\n\t\t\t\t\t\tconst parts = directive\n\t\t\t\t\t\t\t.replace(spacesRegex, '||||||')\n\t\t\t\t\t\t\t.split('||||||')\n\t\t\t\t\t\treturn [parts[0] as CSPDirectiveNames, parts[1] ?? ''] satisfies [\n\t\t\t\t\t\t\tCSPDirectiveNames,\n\t\t\t\t\t\t\tstring,\n\t\t\t\t\t\t]\n\t\t\t\t\t}) ?? [],\n\t\t\t)\n\t\t: {}\n}\n\nexport const patchCspHeader = (\n\tplainHeaders: Record<string, string>,\n\tpageHashes: PerPageHashes,\n\tcspOpts: CSPOptions,\n): void => {\n\tconst directives = Object.hasOwn(plainHeaders, 'content-security-policy')\n\t\t? {\n\t\t\t\t...cspOpts.cspDirectives,\n\t\t\t\t...parseCspDirectives(\n\t\t\t\t\tplainHeaders['content-security-policy'] as string,\n\t\t\t\t),\n\t\t\t}\n\t\t: (cspOpts.cspDirectives ?? ({} satisfies CSPDirectives))\n\n\tif (pageHashes.scripts.size > 0) {\n\t\tsetSrcDirective(directives, 'script-src', pageHashes.scripts)\n\t} else {\n\t\tdirectives['script-src'] = \"'none'\"\n\t}\n\tif (pageHashes.styles.size > 0) {\n\t\tsetSrcDirective(directives, 'style-src', pageHashes.styles)\n\t} else {\n\t\tdirectives['style-src'] = \"'none'\"\n\t}\n\tif (Object.keys(directives).length > 0) {\n\t\tplainHeaders['content-security-policy'] = serialiseCspDirectives(directives)\n\t}\n}\n\nexport const patchHeaders = (\n\theaders: Headers,\n\tpageHashes: PerPageHashes,\n\tsecurityHeadersOpts: SecurityHeadersOptions,\n): Headers => {\n\tconst plainHeaders = Object.fromEntries(headers.entries())\n\n\tif (securityHeadersOpts.contentSecurityPolicy !== undefined) {\n\t\tpatchCspHeader(\n\t\t\tplainHeaders,\n\t\t\tpageHashes,\n\t\t\tsecurityHeadersOpts.contentSecurityPolicy,\n\t\t)\n\t}\n\n\treturn new Headers(plainHeaders)\n}\n","import { readFile, writeFile } from 'node:fs/promises'\n\nimport type {\n\tCSPDirectives,\n\tPerPageHashes,\n\tPerPageHashesCollection,\n\tSecurityHeadersOptions,\n} from './types.mts'\nimport { serialiseCspDirectives, setSrcDirective } from './headers.mts'\nimport { doesFileExist } from './fs.mts'\n\ntype HeaderEntry = {\n\tkey: string\n\tvalue: string\n}\n\ntype CommentEntry = {\n\tcomment: string\n}\n\ntype NetlifyPathHeaders = {\n\tpath: string\n\tentries: (CommentEntry | HeaderEntry)[]\n}\n\ntype EmptyLine = ''\n\nexport type NetlifyHeadersRawConfig = {\n\tindentWith: string\n\tentries: (NetlifyPathHeaders | CommentEntry | EmptyLine)[]\n}\n\nconst spacesRegex = /^\\s+/\nconst headerRegex =\n\t/^(?<indent>\\s*)(?<name>([a-zA-Z0-9_\\-]+)):\\s*(?<value>.*)$/i\nconst commentRegex = /^(?<indent>\\s*)(?<comment>#.*)$/i\n\ntype ParseContext = {\n\tindentWith: string | undefined\n\tentries: NetlifyHeadersRawConfig['entries']\n\tcurrentPath: NetlifyPathHeaders | undefined\n}\n\nconst tryToInitializePathConfig = (\n\tlineNum: number,\n\tline: string,\n\tctx: ParseContext,\n): void => {\n\tif (line === '') {\n\t\tctx.entries.push(line)\n\t} else if (line.startsWith('#')) {\n\t\tctx.entries.push({ comment: line })\n\t} else if (spacesRegex.test(line)) {\n\t\tthrow new Error(`Unexpected indentation (line ${lineNum})`) // TODO: better error message, custom error\n\t} else if (line.startsWith('/')) {\n\t\tctx.currentPath = { path: line, entries: [] }\n\t\tctx.entries.push(ctx.currentPath)\n\t} else {\n\t\tthrow new Error(`Bad syntax (line ${lineNum})`) // TODO: better error message, custom error\n\t}\n}\n\nconst pushComment = (\n\tlineNum: number,\n\tmatch: RegExpMatchArray,\n\tcurrentPath: NetlifyPathHeaders | undefined,\n): void => {\n\tif (match.groups?.comment === undefined) {\n\t\tthrow new Error(`Bad syntax (line ${lineNum})`) // TODO: better error message, custom error\n\t}\n\tcurrentPath?.entries.push({ comment: match.groups.comment })\n}\n\nconst pushHeader = (\n\tlineNum: number,\n\tmatch: RegExpMatchArray,\n\tcurrentPath: NetlifyPathHeaders | undefined,\n): void => {\n\tif (match.groups?.name === undefined || match.groups?.value === undefined) {\n\t\tthrow new Error(`Bad syntax (line ${lineNum})`) // TODO: better error message, custom error\n\t}\n\n\tcurrentPath?.entries.push({\n\t\tkey: match.groups.name,\n\t\tvalue: match.groups.value,\n\t})\n}\n\nconst pushEntry = (\n\tmatch: RegExpMatchArray,\n\tlineNum: number,\n\tline: string,\n\tpushLine: (\n\t\tlineNum: number,\n\t\tmatch: RegExpMatchArray,\n\t\tcurrentPath: NetlifyPathHeaders | undefined,\n\t) => void,\n\tctx: ParseContext,\n): void => {\n\tif (ctx.indentWith === undefined) {\n\t\tif (match.groups?.indent === undefined) {\n\t\t\tthrow new Error(`Bad syntax (line ${lineNum})`) // TODO: better error message, custom error\n\t\t}\n\t\tif (match.groups?.indent === '') {\n\t\t\tthrow new Error(`Unable to infer indentation (line ${lineNum})`) // TODO: better error message, custom error\n\t\t}\n\t\tctx.indentWith = match.groups?.indent\n\t}\n\n\tif (match.groups?.indent === '') {\n\t\tif ((ctx.currentPath?.entries.length ?? 0) === 0) {\n\t\t\tthrow new Error(`Bad syntax (line ${lineNum})`) // TODO: better error message, custom error\n\t\t}\n\t\tctx.currentPath = undefined\n\t\ttryToInitializePathConfig(lineNum, line, ctx)\n\t} else if (match.groups?.indent !== ctx.indentWith) {\n\t\tthrow new Error(`Unexpected indentation (line ${lineNum})`) // TODO: better error message, custom error\n\t} else {\n\t\tpushLine(lineNum, match, ctx.currentPath)\n\t}\n}\n\nconst processPathLine = (\n\tlineNum: number,\n\tline: string,\n\tctx: ParseContext,\n): void => {\n\tlet match: RegExpMatchArray | null = null\n\n\t// biome-ignore lint/suspicious/noAssignInExpressions: best way to do it\n\tif ((match = commentRegex.exec(line))) {\n\t\tpushEntry(match, lineNum, line, pushComment, ctx)\n\t}\n\t// biome-ignore lint/suspicious/noAssignInExpressions: best way to do it\n\telse if ((match = headerRegex.exec(line))) {\n\t\tpushEntry(match, lineNum, line, pushHeader, ctx)\n\t} else if (!spacesRegex.test(line)) {\n\t\tif ((ctx.currentPath?.entries.length ?? 0) === 0) {\n\t\t\tthrow new Error(`Bad syntax (line ${lineNum})`) // TODO: better error message, custom error\n\t\t}\n\t\tctx.currentPath = undefined\n\t\ttryToInitializePathConfig(lineNum, line, ctx)\n\t}\n}\n\nexport const parseNetlifyHeadersConfig = (\n\tconfig: string,\n): NetlifyHeadersRawConfig => {\n\tconst ctx: ParseContext = {\n\t\tindentWith: undefined,\n\t\tentries: [],\n\t\tcurrentPath: undefined,\n\t}\n\n\tfor (const [lineNum, line] of config.split('\\n').entries()) {\n\t\tif (ctx.currentPath === undefined) {\n\t\t\ttryToInitializePathConfig(lineNum, line, ctx)\n\t\t} else {\n\t\t\tprocessPathLine(lineNum, line, ctx)\n\t\t}\n\t}\n\n\treturn {\n\t\tindentWith: ctx.indentWith ?? '\\t',\n\t\tentries: ctx.entries.at(-1) === '' ? ctx.entries.slice(0, -1) : ctx.entries,\n\t}\n}\n\nexport const readNetlifyHeadersFile = async (\n\tpath: string,\n): Promise<NetlifyHeadersRawConfig> => {\n\treturn parseNetlifyHeadersConfig(await readFile(path, 'utf8'))\n}\n\nexport const serializeNetlifyHeadersConfig = (\n\tconfig: NetlifyHeadersRawConfig,\n): string => {\n\tconst indent = config.indentWith\n\tlet result = ''\n\n\tfor (const entry of config.entries) {\n\t\tif (entry === '') {\n\t\t\tresult += '\\n'\n\t\t} else if ('comment' in entry) {\n\t\t\tresult += `${entry.comment}\\n`\n\t\t} else if ('path' in entry) {\n\t\t\tresult += `${entry.path}\\n${entry.entries\n\t\t\t\t.map(e =>\n\t\t\t\t\t'comment' in e\n\t\t\t\t\t\t? `${indent}${e.comment}`\n\t\t\t\t\t\t: `${indent}${e.key}: ${e.value}`,\n\t\t\t\t)\n\t\t\t\t.join('\\n')}\\n`\n\t\t}\n\t}\n\n\treturn result\n}\n\nconst compareConfigEntries = (\n\ta: NetlifyPathHeaders | CommentEntry | EmptyLine,\n\tb: NetlifyPathHeaders | CommentEntry | EmptyLine,\n): -1 | 0 | 1 => {\n\t// We leave comments and empty lines in place\n\treturn a === '' || b === '' || 'comment' in a || 'comment' in b\n\t\t? 0\n\t\t: a.path < b.path\n\t\t\t? -1\n\t\t\t: a.path > b.path\n\t\t\t\t? 1\n\t\t\t\t: 0\n}\n\n/** @internal */\nexport const comparePathEntries = (\n\ta: HeaderEntry | CommentEntry,\n\tb: HeaderEntry | CommentEntry,\n): -1 | 0 | 1 => {\n\t// We leave comments in place\n\treturn 'comment' in a || 'comment' in b\n\t\t? 0\n\t\t: a.key < b.key\n\t\t\t? -1\n\t\t\t: a.key > b.key\n\t\t\t\t? 1\n\t\t\t\t: a.value < b.value // headers can have many values\n\t\t\t\t\t? -1\n\t\t\t\t\t: a.value > b.value\n\t\t\t\t\t\t? 1\n\t\t\t\t\t\t: 0\n}\n\n/** @internal */\nexport const comparePathEntriesSimplified = (\n\ta: HeaderEntry | CommentEntry,\n\tb: HeaderEntry | CommentEntry,\n): -1 | 0 | 1 => {\n\t// We leave comments in place\n\treturn 'comment' in a || 'comment' in b\n\t\t? 0\n\t\t: a.key < b.key\n\t\t\t? -1\n\t\t\t: a.key > b.key\n\t\t\t\t? 1\n\t\t\t\t: 0\n}\n\nexport const buildNetlifyHeadersConfig = (\n\tsecurityHeadersOptions: SecurityHeadersOptions,\n\tperPageSriHashes: PerPageHashesCollection,\n): NetlifyHeadersRawConfig => {\n\tconst config: NetlifyHeadersRawConfig = {\n\t\tindentWith: '\\t',\n\t\tentries: [],\n\t}\n\n\tconst pagesToIterate: [string, PerPageHashes][] = []\n\tfor (const [page, hashes] of perPageSriHashes.entries()) {\n\t\tif (page === 'index.html' || page.endsWith('/index.html')) {\n\t\t\tpagesToIterate.push([page.slice(0, -10), hashes])\n\t\t}\n\t\tpagesToIterate.push([page, hashes])\n\t}\n\tpagesToIterate.sort()\n\n\tfor (const [page, hashes] of pagesToIterate) {\n\t\tconst pathEntries: (HeaderEntry | CommentEntry)[] = []\n\n\t\tif (securityHeadersOptions.contentSecurityPolicy !== undefined) {\n\t\t\tconst directives: CSPDirectives =\n\t\t\t\tsecurityHeadersOptions.contentSecurityPolicy.cspDirectives ?? {}\n\n\t\t\tif (hashes.scripts.size > 0) {\n\t\t\t\tsetSrcDirective(directives, 'script-src', hashes.scripts)\n\t\t\t} else {\n\t\t\t\tdirectives['script-src'] = \"'none'\"\n\t\t\t}\n\t\t\tif (hashes.styles.size > 0) {\n\t\t\t\tsetSrcDirective(directives, 'style-src', hashes.styles)\n\t\t\t} else {\n\t\t\t\tdirectives['style-src'] = \"'none'\"\n\t\t\t}\n\n\t\t\tif (Object.keys(directives).length === 0) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpathEntries.push({\n\t\t\t\tkey: 'content-security-policy',\n\t\t\t\tvalue: serialiseCspDirectives(directives),\n\t\t\t})\n\t\t}\n\n\t\tif (pathEntries.length > 0) {\n\t\t\tconfig.entries.push({\n\t\t\t\tpath: `/${page}`,\n\t\t\t\tentries: pathEntries.sort(comparePathEntries),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn config\n}\n\nconst mergeNetlifyPathHeaders = (\n\tbase: (HeaderEntry | CommentEntry)[],\n\tpatch: (HeaderEntry | CommentEntry)[],\n): (HeaderEntry | CommentEntry)[] => {\n\tconst merged: (HeaderEntry | CommentEntry)[] = []\n\n\tlet baseIndex = 0\n\tlet patchIndex = 0\n\twhile (baseIndex < base.length && patchIndex < patch.length) {\n\t\t// biome-ignore lint/style/noNonNullAssertion: element is guaranteed to exist\n\t\tconst baseEntry = base[baseIndex]!\n\t\t// biome-ignore lint/style/noNonNullAssertion: element is guaranteed to exist\n\t\tconst patchEntry = patch[patchIndex]!\n\n\t\tswitch (comparePathEntriesSimplified(baseEntry, patchEntry)) {\n\t\t\tcase -1: {\n\t\t\t\tmerged.push(baseEntry)\n\t\t\t\tbaseIndex += 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 0: {\n\t\t\t\tif ('comment' in patchEntry) {\n\t\t\t\t\tpatchIndex += 1 // We discard comments in the patch\n\t\t\t\t} else if ('comment' in baseEntry) {\n\t\t\t\t\tmerged.push(baseEntry)\n\t\t\t\t\tbaseIndex += 1\n\t\t\t\t} else {\n\t\t\t\t\tmerged.push(patchEntry)\n\t\t\t\t\tbaseIndex += 1\n\t\t\t\t\tpatchIndex += 1\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 1: {\n\t\t\t\tmerged.push(patchEntry)\n\t\t\t\tpatchIndex += 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('Unreachable')\n\t\t\t}\n\t\t}\n\t}\n\tfor (; baseIndex < base.length; baseIndex += 1) {\n\t\t// biome-ignore lint/style/noNonNullAssertion: guaranteed to exist\n\t\tmerged.push(base[baseIndex]!)\n\t}\n\tfor (; patchIndex < patch.length; patchIndex += 1) {\n\t\t// biome-ignore lint/style/noNonNullAssertion: guaranteed to exist\n\t\tmerged.push(patch[patchIndex]!)\n\t}\n\n\treturn merged\n}\n\nexport const mergeNetlifyHeadersConfig = (\n\tbase: NetlifyHeadersRawConfig,\n\tpatch: NetlifyHeadersRawConfig,\n): NetlifyHeadersRawConfig => {\n\tconst indentWith = base.indentWith\n\tconst baseEntries = base.entries.slice().sort(compareConfigEntries)\n\tconst patchEntries = patch.entries.slice().sort(compareConfigEntries)\n\tconst mergedEntries: NetlifyHeadersRawConfig['entries'] = []\n\n\tlet baseIndex = 0\n\tlet patchIndex = 0\n\twhile (baseIndex < baseEntries.length && patchIndex < patchEntries.length) {\n\t\t// biome-ignore lint/style/noNonNullAssertion: element is guaranteed to exist\n\t\tconst baseEntry = baseEntries[baseIndex]!\n\t\t// biome-ignore lint/style/noNonNullAssertion: element is guaranteed to exist\n\t\tconst patchEntry = patchEntries[patchIndex]!\n\n\t\tswitch (compareConfigEntries(baseEntry, patchEntry)) {\n\t\t\tcase -1: {\n\t\t\t\tif (\n\t\t\t\t\t!(\n\t\t\t\t\t\ttypeof baseEntry === 'object' &&\n\t\t\t\t\t\t'entries' in baseEntry &&\n\t\t\t\t\t\tbaseEntry.entries.length === 0\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\t// We discard entries with no headers nor comments\n\t\t\t\t\tmergedEntries.push(baseEntry)\n\t\t\t\t}\n\t\t\t\tbaseIndex += 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 0: {\n\t\t\t\tif (patchEntry === '' || 'comment' in patchEntry) {\n\t\t\t\t\tpatchIndex += 1 // We discard comments in the patch\n\t\t\t\t} else if (baseEntry === '' || 'comment' in baseEntry) {\n\t\t\t\t\tmergedEntries.push(patchEntry)\n\t\t\t\t\tpatchIndex += 1\n\t\t\t\t} else if (baseEntry.path === patchEntry.path) {\n\t\t\t\t\tmergedEntries.push({\n\t\t\t\t\t\tpath: baseEntry.path,\n\t\t\t\t\t\tentries: mergeNetlifyPathHeaders(\n\t\t\t\t\t\t\tbaseEntry.entries,\n\t\t\t\t\t\t\tpatchEntry.entries,\n\t\t\t\t\t\t),\n\t\t\t\t\t})\n\t\t\t\t\tbaseIndex += 1\n\t\t\t\t\tpatchIndex += 1\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Unreachable')\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 1: {\n\t\t\t\tif (\n\t\t\t\t\t!(\n\t\t\t\t\t\ttypeof patchEntry === 'object' &&\n\t\t\t\t\t\t'entries' in patchEntry &&\n\t\t\t\t\t\tpatchEntry.entries.length === 0\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\t// We discard entries with no headers nor comments\n\t\t\t\t\tmergedEntries.push(patchEntry)\n\t\t\t\t}\n\t\t\t\tpatchIndex += 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unreachable')\n\t\t}\n\t}\n\tfor (; baseIndex < baseEntries.length; baseIndex += 1) {\n\t\t// biome-ignore lint/style/noNonNullAssertion: element is guaranteed to exist\n\t\tmergedEntries.push(baseEntries[baseIndex]!)\n\t}\n\tfor (; patchIndex < patchEntries.length; patchIndex += 1) {\n\t\t// biome-ignore lint/style/noNonNullAssertion: element is guaranteed to exist\n\t\tmergedEntries.push(patchEntries[patchIndex]!)\n\t}\n\n\treturn {\n\t\tindentWith,\n\t\tentries: mergedEntries,\n\t}\n}\n\nexport const patchNetlifyHeadersConfig = async (\n\tconfigPath: string,\n\tsecurityHeadersOptions: SecurityHeadersOptions,\n\tperPageSriHashes: PerPageHashesCollection,\n): Promise<void> => {\n\tconst baseConfig = (await doesFileExist(configPath))\n\t\t? await readNetlifyHeadersFile(configPath)\n\t\t: { indentWith: '\\t', entries: [] }\n\n\tconst patchConfig = buildNetlifyHeadersConfig(\n\t\tsecurityHeadersOptions,\n\t\tperPageSriHashes,\n\t)\n\n\tconst mergedConfig = mergeNetlifyHeadersConfig(baseConfig, patchConfig)\n\n\tawait writeFile(configPath, serializeNetlifyHeadersConfig(mergedConfig))\n}\n","/** @internal */\nexport const exhaustiveGuard = (_v: never, caseName: string): void => {\n\tthrow new Error(`Unknown ${caseName}: ${_v}`)\n}\n","import { resolve } from 'node:path'\nimport type {\n\tCSPDirectives,\n\tLogger,\n\tPerPageHashes,\n\tPerPageHashesCollection,\n\tSecurityHeadersOptions,\n} from './types.mts'\nimport { doesFileExist } from './fs.mts'\nimport { readFile, writeFile, readdir } from 'node:fs/promises'\nimport type { AstroConfig } from 'astro'\nimport { serialiseCspDirectives, setSrcDirective } from './headers.mts'\n\ntype VercelRoute = {\n\tsrc: string\n\theaders?: Record<string, string>\n\tstatus?: number\n\t[key: string]: unknown\n}\n\ntype VercelConfigV3 = {\n\tversion: number\n\troutes?: VercelRoute[]\n}\n\nexport type VercelConfig = VercelConfigV3\n\nconst vercelAdapterDistRegexp = /\\.vercel\\/output\\/static\\/?$/\n\nexport const parseVercelConfig = (\n\tlogger: Logger,\n\tconfig: string,\n): VercelConfig => {\n\tconst parsed = JSON.parse(config)\n\n\t// TODO: Improve validation and error handling\n\tif (!('version' in parsed)) {\n\t\tthrow new Error('Invalid Vercel config: missing \"version\" field')\n\t}\n\tif (parsed.version !== 3) {\n\t\tlogger.warn(\n\t\t\t`Expected Vercel config version 3, but got version ${parsed.version}`,\n\t\t)\n\t}\n\n\treturn parsed as VercelConfig\n}\n\nexport const readVercelConfigFile = async (\n\tlogger: Logger,\n\tpath: string,\n): Promise<VercelConfig> => {\n\treturn parseVercelConfig(logger, await readFile(path, 'utf8'))\n}\n\nexport const buildVercelConfig = (\n\tastroConfig: Partial<AstroConfig>,\n\tsecurityHeadersOptions: SecurityHeadersOptions,\n\tperPageSriHashes: PerPageHashesCollection,\n): VercelConfig => {\n\tconst indexSlashOffset =\n\t\tastroConfig.trailingSlash === 'never'\n\t\t\t? -11\n\t\t\t: astroConfig.trailingSlash === 'always'\n\t\t\t\t? -10\n\t\t\t\t: undefined\n\n\tconst pagesToIterate: [string, PerPageHashes][] = []\n\tfor (const [page, hashes] of perPageSriHashes.entries()) {\n\t\tif (\n\t\t\tindexSlashOffset !== undefined &&\n\t\t\t(page === 'index.html' || page.endsWith('/index.html'))\n\t\t) {\n\t\t\tpagesToIterate.push([page.slice(0, indexSlashOffset), hashes])\n\t\t}\n\t\tpagesToIterate.push([page, hashes])\n\t}\n\tpagesToIterate.sort()\n\n\tconst routes: VercelRoute[] = []\n\tfor (const [page, hashes] of pagesToIterate) {\n\t\tconst headers: Record<string, string> = {}\n\n\t\tif (securityHeadersOptions.contentSecurityPolicy !== undefined) {\n\t\t\tconst directives: CSPDirectives =\n\t\t\t\tsecurityHeadersOptions.contentSecurityPolicy.cspDirectives ?? {}\n\n\t\t\tif (hashes.scripts.size > 0) {\n\t\t\t\tsetSrcDirective(directives, 'script-src', hashes.scripts)\n\t\t\t} else {\n\t\t\t\tdirectives['script-src'] = \"'none'\"\n\t\t\t}\n\t\t\tif (hashes.styles.size > 0) {\n\t\t\t\tsetSrcDirective(directives, 'style-src', hashes.styles)\n\t\t\t} else {\n\t\t\t\tdirectives['style-src'] = \"'none'\"\n\t\t\t}\n\n\t\t\tif (Object.keys(directives).length === 0) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\theaders['content-security-policy'] = serialiseCspDirectives(directives)\n\t\t}\n\n\t\tif (Object.keys(headers).length > 0) {\n\t\t\troutes.push({\n\t\t\t\tsrc: `^/${page.replaceAll('.', '\\\\.')}$`,\n\t\t\t\theaders,\n\t\t\t\tcontinue: true,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn { version: 3, routes }\n}\n\nexport const mergeVercelConfig = (\n\tbase: VercelConfig,\n\tpatch: VercelConfig,\n): VercelConfig => {\n\treturn { ...base, routes: [...(patch.routes ?? []), ...(base.routes ?? [])] }\n}\n\nexport const serializeVercelConfig = (config: VercelConfig): string => {\n\treturn JSON.stringify(config, null, '\\t')\n}\n\nexport const patchVercelHeadersConfig = async (\n\tlogger: Logger,\n\tdistDir: string,\n\tastroConfig: Partial<AstroConfig>,\n\tsecurityHeadersOptions: SecurityHeadersOptions,\n\tperPageSriHashes: PerPageHashesCollection,\n): Promise<void> => {\n\tif (!vercelAdapterDistRegexp.test(distDir)) {\n\t\tlogger.warn(\n\t\t\t'\"@astrojs/vercel/static\" adapter not detected, but \"securityHeaders.enableOnStaticPages.provider\" is set to \"vercel\". See https://docs.astro.build/en/guides/integrations-guide/vercel/#choosing-a-target to learn how to set up the adapter.',\n\t\t)\n\t\treturn\n\t}\n\tconst configPath = resolve(distDir, '..', 'config.json')\n\tif (!(await doesFileExist(configPath))) {\n\t\tlogger.error(\n\t\t\t`Vercel adapter detected, but \"config.json\" not found in \"${configPath}\".`,\n\t\t)\n\t\tlogger.error(JSON.stringify(await readdir(resolve(distDir))))\n\t\tlogger.error(JSON.stringify(await readdir(resolve(distDir, '..'))))\n\t\treturn\n\t}\n\n\tconst baseConfig = await readVercelConfigFile(logger, configPath)\n\n\tconst patchConfig = buildVercelConfig(\n\t\tastroConfig,\n\t\tsecurityHeadersOptions,\n\t\tperPageSriHashes,\n\t)\n\n\tconst mergedConfig = mergeVercelConfig(baseConfig, patchConfig)\n\n\tawait writeFile(configPath, serializeVercelConfig(mergedConfig))\n}\n","/*\n * SPDX-FileCopyrightText: 2024 KindSpells Labs S.L.\n *\n * SPDX-License-Identifier: MIT\n */\n\nimport { createHash } from 'node:crypto'\nimport { mkdir, readFile, writeFile } from 'node:fs/promises'\nimport { dirname, extname, relative, resolve } from 'node:path'\nimport { fileURLToPath } from 'node:url'\n\nimport type { AstroIntegration, MiddlewareHandler } from 'astro'\nimport type { Plugin } from 'vite'\n\nimport { doesFileExist, scanDirectory } from './fs.mts'\nimport { patchHeaders } from './headers.mts'\nimport type {\n\tHashesCollection,\n\tIntegrationState,\n\tLogger,\n\tMiddlewareHashes,\n\tPerPageHashes,\n\tSecurityHeadersOptions,\n\tSRIOptions,\n\tStrictShieldOptions,\n} from './types.mts'\nimport { patchNetlifyHeadersConfig } from './netlify.mts'\nimport { exhaustiveGuard } from './utils.mts'\nimport { patchVercelHeadersConfig } from './vercel.mts'\n\ntype AstroHooks = AstroIntegration['hooks']\n\nexport type HashesModule = {\n\t[k in keyof HashesCollection]: HashesCollection[k] extends Set<string>\n\t\t? string[] | undefined\n\t\t: k extends 'perPageSriHashes'\n\t\t\t? Record<string, { scripts: string[]; styles: string[] }>\n\t\t\t: Record<'scripts' | 'styles', Record<string, string>>\n}\n\nexport const generateSRIHash = (\n\tdata: string | ArrayBuffer | Buffer,\n): string => {\n\tconst hash = createHash('sha256')\n\tif (data instanceof ArrayBuffer) {\n\t\thash.update(Buffer.from(data))\n\t} else if (data instanceof Buffer) {\n\t\thash.update(data)\n\t} else {\n\t\thash.update(data, 'utf8')\n\t}\n\treturn `sha256-${hash.digest('base64')}`\n}\n\ntype ElemReplacer = (\n\thash: string,\n\tattrs: string,\n\tsetCrossorigin: boolean,\n\tcontent?: string | undefined,\n) => string\n\nconst scriptReplacer: ElemReplacer = (hash, attrs, setCrossorigin, content) =>\n\t`<script${attrs} integrity=\"${hash}\"${\n\t\tsetCrossorigin ? ' crossorigin=\"anonymous\"' : ''\n\t}>${content ?? ''}</script>`\n\nconst styleReplacer: ElemReplacer = (hash, attrs, setCrossorigin, content) =>\n\t`<style${attrs} integrity=\"${hash}\"${\n\t\tsetCrossorigin ? ' crossorigin=\"anonymous\"' : ''\n\t}>${content ?? ''}</style>`\n\nconst linkStyleReplacer: ElemReplacer = (hash, attrs, setCrossorigin) =>\n\t`<link${attrs} integrity=\"${hash}\"${\n\t\tsetCrossorigin ? ' crossorigin=\"anonymous\"' : ''\n\t}/>`\n\nconst urlLikeRegex = /^(https?:)?\\/\\/[^/]/i\nconst anonymousCrossOriginRegex =\n\t/crossorigin\\s*=\\s*(\"anonymous\"|'anonymous'|anonymous)/i\nconst integrityRegex =\n\t/^integrity\\s*=\\s*(\"(?<integrity1>sha256-[a-z0-9+\\/]{43}=)\"|'(?<integrity2>sha256-[a-z0-9+\\/]{43}=)')$/i\nconst relStylesheetRegex =\n\t/(^|\\s+)rel\\s*=\\s*('stylesheet'|\"stylesheet\"|stylesheet(\\s+?|$))/i\nconst naiveAttrSplitter = /(?<!=)\\s+(?!=)/\n\nconst extractIntegrityHash = (attrs: string): string | undefined => {\n\tfor (const attr of attrs.split(naiveAttrSplitter)) {\n\t\t// If longer than 128, it's either not an integrity attribute, or an attempt\n\t\t// to perform a DoS attack.\n\t\tif (attr.length <= 128) {\n\t\t\tconst m = integrityRegex.exec(attr)\n\t\t\tif (m) {\n\t\t\t\treturn m.groups?.integrity1 ?? m.groups?.integrity2\n\t\t\t}\n\t\t}\n\t}\n\treturn undefined\n}\n\nexport const regexProcessors = [\n\t{\n\t\tt: 'Script' as const,\n\t\tt2: 'scripts' as const,\n\t\tregex:\n\t\t\t/<script(?<attrs>(\\s+[a-z][a-z0-9\\-_]*(\\s*=\\s*('[^']*'|\"[^\"]*\"|[a-z0-9\\-_\\/\\.]+))?)*?)\\s*>(?<content>[\\s\\S]*?)<\\/\\s*script((?<closingTrick>(\\s+[a-z][a-z0-9\\-_]*(\\s*=\\s*('[^']*'|\"[^\"]*\"|[a-z0-9\\-_]+))?)+?)|\\s*>)/gi,\n\t\tsrcRegex:\n\t\t\t/(^|\\s+)src\\s*=\\s*(\"(?<src1>[^\"]*)\"|'(?<src2>[^']*)'|(?<src3>[a-z0-9\\-_\\/\\.]+))/i,\n\t\treplacer: scriptReplacer,\n\t\thasContent: true,\n\t\tattrsRegex: undefined,\n\t},\n\t{\n\t\tt: 'Style' as const,\n\t\tt2: 'styles' as const,\n\t\tregex:\n\t\t\t/<style(?<attrs>(\\s+[a-z][a-z0-9\\-_]*(\\s*=\\s*('[^']*'|\"[^\"]*\"|[a-z0-9\\-_\\/\\.]+))?)*?)\\s*>(?<content>[\\s\\S]*?)<\\/\\s*style((?<closingTrick>(\\s+[a-z][a-z0-9\\-_]*(\\s*=\\s*('[^']*'|\"[^\"]*\"|[a-z0-9\\-_]+))?)+?)|\\s*>)/gi,\n\t\tsrcRegex:\n\t\t\t/(^|\\s+)(href|src)\\s*=\\s*(\"(?<src1>[^\"]*)\"|'(?<src2>[^']*)'|(?<src3>[a-z0-9\\-_\\/\\.]+))/i, // not really used\n\t\treplacer: styleReplacer,\n\t\thasContent: true,\n\t\tattrsRegex: undefined,\n\t},\n\t{\n\t\tt: 'Style' as const,\n\t\tt2: 'styles' as const,\n\t\tregex:\n\t\t\t/<link(?<attrs>(\\s+[a-z][a-z0-9\\-_]*(\\s*=\\s*('[^']*'|\"[^\"]*\"|[a-z0-9\\-_\\/\\.]+))?)*?)\\s*\\/?>/gi,\n\t\tsrcRegex:\n\t\t\t/(^|\\s+)href\\s*=\\s*(\"(?<src1>[^\"]*)\"|'(?<src2>[^']*)'|(?<src3>[a-z0-9\\-_\\/\\.]+))/i,\n\t\treplacer: linkStyleReplacer,\n\t\thasContent: false,\n\t\tattrsRegex: relStylesheetRegex,\n\t},\n] as const\n\n/**\n * This function extracts SRI hashes from inline and external resources, and\n * adds the integrity attribute to the related HTML elements.\n *\n * Notice that it assumes that the HTML content is relatively well-formed, and\n * that in case it already contains integrity attributes then they are correct.\n */\nexport const updateStaticPageSriHashes = async (\n\tlogger: Logger,\n\tdistDir: string,\n\trelativeFilepath: string,\n\tcontent: string,\n\th: HashesCollection,\n\tallowInlineScripts: 'all' | 'static' | false = 'all',\n\tallowInlineStyles: 'all' | 'static' | false = 'all',\n\tstate?: IntegrationState,\n): Promise<string> => {\n\tconst pageHashes =\n\t\th.perPageSriHashes.get(relativeFilepath) ??\n\t\t({\n\t\t\tscripts: new Set(),\n\t\t\tstyles: new Set(),\n\t\t} satisfies PerPageHashes)\n\th.perPageSriHashes.set(relativeFilepath, pageHashes)\n\n\tlet updatedContent = content\n\tlet match: RegExpExecArray | null\n\n\tfor (const {\n\t\tattrsRegex,\n\t\thasContent,\n\t\tregex,\n\t\tsrcRegex,\n\t\treplacer,\n\t\tt,\n\t\tt2,\n\t} of regexProcessors) {\n\t\tregex.lastIndex = 0 // We have to reset `regex`'s state, because it's \"global\"\n\n\t\t// biome-ignore lint/suspicious/noAssignInExpressions: safe\n\t\twhile ((match = regex.exec(content)) !== null) {\n\t\t\tconst attrs = match.groups?.attrs?.trim() ?? ''\n\n\t\t\t// We trim elemContent ONLY if it's made out of 100% whitespace characters\n\t\t\tconst _elemContent = match.groups?.content ?? ''\n\t\t\tconst elemContent = _elemContent.trim() === '' ? '' : _elemContent\n\n\t\t\tlet sriHash: string | undefined = undefined\n\t\t\tlet setCrossorigin = false\n\n\t\t\tif (attrs) {\n\t\t\t\tif (attrsRegex && !attrsRegex.test(attrs)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst srcMatch = srcRegex.exec(attrs)\n\t\t\t\tconst src =\n\t\t\t\t\tsrcMatch?.groups?.src1 ??\n\t\t\t\t\tsrcMatch?.groups?.src2 ??\n\t\t\t\t\tsrcMatch?.groups?.src3 ??\n\t\t\t\t\t''\n\n\t\t\t\tif (elemContent && src) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`${t} \"${src}\" must have either a src/href attribute or content, but not both. Removing it.`,\n\t\t\t\t\t)\n\t\t\t\t\tupdatedContent = updatedContent.replace(match[0], '')\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst givenSriHash = extractIntegrityHash(attrs)\n\n\t\t\t\tif (givenSriHash !== undefined) {\n\t\t\t\t\tif (givenSriHash) {\n\t\t\t\t\t\t;(srcMatch ? h[`ext${t}Hashes`] : h[`inline${t}Hashes`]).add(\n\t\t\t\t\t\t\tgivenSriHash,\n\t\t\t\t\t\t)\n\t\t\t\t\t\tpageHashes[t2].add(givenSriHash)\n\t\t\t\t\t\tif (src) {\n\t\t\t\t\t\t\th.perResourceSriHashes[t2].set(src, givenSriHash)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t`Found empty integrity attribute in \"${relativeFilepath}\".`,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif (src) {\n\t\t\t\t\tconst cachedHash = h.perResourceSriHashes[t2].get(src)\n\t\t\t\t\tif (cachedHash) {\n\t\t\t\t\t\tsriHash = cachedHash\n\t\t\t\t\t\th[`ext${t}Hashes`].add(sriHash)\n\t\t\t\t\t\tpageHashes[t2].add(sriHash)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet resourceContent: string | ArrayBuffer | Buffer\n\t\t\t\t\t\tif (urlLikeRegex.test(src)) {\n\t\t\t\t\t\t\tsetCrossorigin = true\n\t\t\t\t\t\t\tconst resourceResponse = await fetch(\n\t\t\t\t\t\t\t\tsrc.startsWith('//') ? `https:${src}` : src,\n\t\t\t\t\t\t\t\t{ method: 'GET' },\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tresourceContent = await resourceResponse.arrayBuffer()\n\t\t\t\t\t\t} else if (src.startsWith('/')) {\n\t\t\t\t\t\t\tconst base = state?.config.base ?? ''\n\t\t\t\t\t\t\tconst updatedSrc = src.startsWith(base)\n\t\t\t\t\t\t\t\t? src.replace(base, '')\n\t\t\t\t\t\t\t\t: src\n\t\t\t\t\t\t\tconst resourcePath = resolve(distDir, `.${updatedSrc}`)\n\t\t\t\t\t\t\tresourceContent = await readFile(resourcePath)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TODO: should we remove the element?\n\t\t\t\t\t\t\tlogger.warn(`Unable to process external resource: \"${src}\"`)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsriHash = generateSRIHash(resourceContent)\n\t\t\t\t\t\th[`ext${t}Hashes`].add(sriHash)\n\t\t\t\t\t\tpageHashes[t2].add(sriHash)\n\t\t\t\t\t\th.perResourceSriHashes[t2].set(src, sriHash)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasContent && !sriHash) {\n\t\t\t\tif (\n\t\t\t\t\t!(allowInlineScripts === false && t === 'Script') &&\n\t\t\t\t\t!(allowInlineStyles === false && t === 'Style')\n\t\t\t\t) {\n\t\t\t\t\tsriHash = generateSRIHash(elemContent)\n\t\t\t\t\th[`inline${t}Hashes`].add(sriHash)\n\t\t\t\t\tpageHashes[t2].add(sriHash)\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: TEST CASE!\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Removing inline ${t.toLowerCase()} block (inline ${t2} are disabled).`,\n\t\t\t\t\t)\n\t\t\t\t\tupdatedContent = updatedContent.replace(match[0], '')\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sriHash) {\n\t\t\t\tconst hasAnonymousCrossOrigin = anonymousCrossOriginRegex.test(attrs)\n\n\t\t\t\tupdatedContent = updatedContent.replace(\n\t\t\t\t\tmatch[0],\n\t\t\t\t\treplacer(\n\t\t\t\t\t\tsriHash,\n\t\t\t\t\t\tattrs ? ` ${attrs}` : '',\n\t\t\t\t\t\tsetCrossorigin && !hasAnonymousCrossOrigin,\n\t\t\t\t\t\telemContent,\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn updatedContent\n}\n\nexport const updateDynamicPageSriHashes = (\n\tlogger: Logger,\n\tcontent: string,\n\tglobalHashes: MiddlewareHashes,\n\tsri?: SRIOptions,\n): { pageHashes: PerPageHashes; updatedContent: string } => {\n\tlet updatedContent = content\n\tlet match: RegExpExecArray | null\n\n\tconst pageHashes: PerPageHashes = {\n\t\tscripts: new Set(),\n\t\tstyles: new Set(),\n\t}\n\n\tfor (const {\n\t\tattrsRegex,\n\t\thasContent,\n\t\tregex,\n\t\tsrcRegex,\n\t\treplacer,\n\t\tt,\n\t\tt2,\n\t} of regexProcessors) {\n\t\tregex.lastIndex = 0 // We have to reset `regex`'s state, because it's \"global\"\n\n\t\t// biome-ignore lint/suspicious/noAssignInExpressions: safe\n\t\twhile ((match = regex.exec(content)) !== null) {\n\t\t\tconst attrs = match.groups?.attrs?.trim() ?? ''\n\n\t\t\t// We trim elemContent ONLY if it's made out of 100% whitespace characters\n\t\t\tconst _elemContent = match.groups?.content ?? ''\n\t\t\tconst elemContent = _elemContent.trim() === '' ? '' : _elemContent\n\n\t\t\tlet sriHash: string | undefined = undefined\n\t\t\tlet setCrossorigin = false\n\n\t\t\tif (attrs) {\n\t\t\t\t// This is to skip <link> elements that are not stylesheets\n\t\t\t\tif (attrsRegex && !attrsRegex.test(attrs)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst srcMatch = srcRegex.exec(attrs)\n\t\t\t\tconst src =\n\t\t\t\t\tsrcMatch?.groups?.src1 ??\n\t\t\t\t\tsrcMatch?.groups?.src2 ??\n\t\t\t\t\tsrcMatch?.groups?.src3\n\n\t\t\t\tif (elemContent && src) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`${t} \"${src}\" must have either a src/href attribute or content, but not both. Removing it.`,\n\t\t\t\t\t)\n\t\t\t\t\tupdatedContent = updatedContent.replace(match[0], '')\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tconst givenSriHash = extractIntegrityHash(attrs)\n\n\t\t\t\tif (givenSriHash !== undefined) {\n\t\t\t\t\tif (givenSriHash) {\n\t\t\t\t\t\tif (src) {\n\t\t\t\t\t\t\tconst globalHash = globalHashes[t2].get(src)\n\t\t\t\t\t\t\tif (globalHash) {\n\t\t\t\t\t\t\t\tif (globalHash !== givenSriHash) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\t`Detected integrity hash mismatch for resource \"${src}\". Removing it.`,\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\tupdatedContent = updatedContent.replace(match[0], '')\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tsriHash = givenSriHash\n\t\t\t\t\t\t\t\t\tpageHashes[t2].add(sriHash)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t`Detected reference to not explicitly allowed external resource \"${src}\". Removing it.`,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tupdatedContent = updatedContent.replace(match[0], '')\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (elemContent) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(t2 === 'scripts' &&\n\t\t\t\t\t\t\t\t\t(sri?.allowInlineScripts ?? 'all') === 'all') ||\n\t\t\t\t\t\t\t\t(t2 === 'styles' && (sri?.allowInlineStyles ?? 'all') === 'all')\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tsriHash = givenSriHash\n\t\t\t\t\t\t\t\tpageHashes[t2].add(sriHash)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t`Removing inline ${t.toLowerCase()} block (inline ${t2} are disabled).`,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tupdatedContent = updatedContent.replace(match[0], '')\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t`Found empty integrity attribute, removing inline ${t.toLowerCase()} block.`,\n\t\t\t\t\t\t)\n\t\t\t\t\t\tupdatedContent = updatedContent.replace(match[0], '')\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif (src) {\n\t\t\t\t\tif (urlLikeRegex.test(src)) {\n\t\t\t\t\t\tsetCrossorigin = true\n\t\t\t\t\t\tsriHash = globalHashes[t2].get(src)\n\n\t\t\t\t\t\tif (sriHash) {\n\t\t\t\t\t\t\tpageHashes[t2].add(sriHash)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t`Detected reference to not explicitly allowed external resource \"${src}\". Removing it.`,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tupdatedContent = updatedContent.replace(match[0], '')\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (src.startsWith('/')) {\n\t\t\t\t\t\tsriHash = globalHashes[t2].get(src)\n\t\t\t\t\t\tif (sriHash) {\n\t\t\t\t\t\t\tpageHashes[t2].add(sriHash)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\t\tsrc.startsWith('/@vite/') ||\n\t\t\t\t\t\t\t\t\tsrc.startsWith('/@fs/') ||\n\t\t\t\t\t\t\t\t\tsrc.indexOf('?astro&type=') >= 0\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t// TODO: Perform fetch operation when running in dev mode\n\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t`Unable to obtain SRI hash for local resource: \"${src}\"`,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// TODO: Introduce flag to decide if external resources using unknown protocols should be removed\n\t\t\t\t\t\t// TODO: TEST CASE!\n\t\t\t\t\t\tlogger.warn(`Unable to process external resource: \"${src}\".`)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasContent && !sriHash) {\n\t\t\t\tif (\n\t\t\t\t\t((sri?.allowInlineScripts ?? 'all') === 'all' && t === 'Script') ||\n\t\t\t\t\t((sri?.allowInlineStyles ?? 'all') === 'all' && t === 'Style')\n\t\t\t\t) {\n\t\t\t\t\tsriHash = generateSRIHash(elemContent)\n\t\t\t\t\tpageHashes[t2].add(sriHash)\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Removing inline ${t.toLowerCase()} block (inline ${t2} are disabled)`,\n\t\t\t\t\t)\n\t\t\t\t\tupdatedContent = updatedContent.replace(match[0], '')\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sriHash) {\n\t\t\t\tconst hasAnonymousCrossOrigin = anonymousCrossOriginRegex.test(attrs)\n\n\t\t\t\tupdatedContent = updatedContent.replace(\n\t\t\t\t\tmatch[0],\n\t\t\t\t\treplacer(\n\t\t\t\t\t\tsriHash,\n\t\t\t\t\t\tattrs ? ` ${attrs}` : '',\n\t\t\t\t\t\tsetCrossorigin && !hasAnonymousCrossOrigin,\n\t\t\t\t\t\telemContent,\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tpageHashes,\n\t\tupdatedContent,\n\t}\n}\n\nconst processHTMLFile = async (\n\tlogger: Logger,\n\tfilePath: string,\n\tdistDir: string,\n\th: HashesCollection,\n\tsri?: SRIOptions,\n\tstate?: IntegrationState,\n): Promise<void> => {\n\tconst content = await readFile(filePath, 'utf8')\n\tconst updatedContent = await updateStaticPageSriHashes(\n\t\tlogger,\n\t\tdistDir,\n\t\trelative(distDir, filePath),\n\t\tcontent,\n\t\th,\n\t\tsri?.allowInlineScripts ?? 'all',\n\t\tsri?.allowInlineStyles ?? 'all',\n\t\tstate,\n\t)\n\n\tif (updatedContent !== content) {\n\t\tawait writeFile(filePath, updatedContent)\n\t}\n}\n\nexport const arraysEqual = (a: unknown[], b: unknown[]): boolean => {\n\tif (a.length !== b.length) {\n\t\treturn false\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nexport const pageHashesEqual = (\n\ta: Record<string, { scripts: string[]; styles: string[] }>,\n\tb: Record<string, { scripts: string[]; styles: string[] }>,\n): boolean => {\n\tconst aKeys = Object.keys(a).sort()\n\tconst bKeys = Object.keys(b).sort()\n\n\tif (!arraysEqual(aKeys, bKeys)) {\n\t\treturn false\n\t}\n\n\tfor (const [aKey, aValue] of Object.entries(a)) {\n\t\tconst bValue = b[aKey]\n\t\tif (!bValue) {\n\t\t\treturn false // TODO: TEST CASE!\n\t\t}\n\n\t\tif (\n\t\t\t!arraysEqual(aValue.scripts, bValue.scripts) ||\n\t\t\t!arraysEqual(aValue.styles, bValue.styles)\n\t\t) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nexport const sriHashesEqual = (\n\ta: { scripts: Record<string, string>; styles: Record<string, string> },\n\tb: { scripts: Record<string, string>; styles: Record<string, string> },\n): boolean => {\n\tconst aScriptsKeys = Object.keys(a.scripts).sort()\n\tconst bScriptsKeys = Object.keys(b.scripts).sort()\n\tconst aStylesKeys = Object.keys(a.styles).sort()\n\tconst bStylesKeys = Object.keys(b.styles).sort()\n\n\tif (\n\t\t!arraysEqual(aScriptsKeys, bScriptsKeys) ||\n\t\t!arraysEqual(aStylesKeys, bStylesKeys)\n\t) {\n\t\treturn false\n\t}\n\n\tfor (const [aKey, aValue] of Object.entries(a.scripts)) {\n\t\tif (b.scripts[aKey] !== aValue) {\n\t\t\treturn false // TODO: TEST CASE!\n\t\t}\n\t}\n\tfor (const [aKey, aValue] of Object.entries(a.styles)) {\n\t\tif (b.styles[aKey] !== aValue) {\n\t\t\treturn false // TODO: TEST CASE!\n\t\t}\n\t}\n\n\treturn true\n}\n\n/**\n * This is a hack to scan for nested scripts in the `_astro` directory, but they\n * should be detected in a recursive way, when we process the JS files that are\n * being directly imported in the HTML files.\n */\nexport const scanForNestedResources = async (\n\tlogger: Logger,\n\tdirPath: string,\n\th: HashesCollection,\n): Promise<void> => {\n\tawait scanDirectory(\n\t\tlogger,\n\t\tdirPath,\n\t\tdirPath,\n\t\th,\n\t\tasync (_logger, _filePath, _distDir, _h) => {\n\t\t\tconst relativePath = `/${relative(_distDir, _filePath)}`\n\n\t\t\tconst ext = extname(_filePath)\n\t\t\tif (['.js', '.mjs'].includes(ext)) {\n\t\t\t\tif (!_h.perResourceSriHashes.scripts.has(relativePath)) {\n\t\t\t\t\tconst sriHash = generateSRIHash(await readFile(_filePath))\n\t\t\t\t\t_h.extScriptHashes.add(sriHash)\n\t\t\t\t\t_h.perResourceSriHashes.scripts.set(relativePath, sriHash)\n\t\t\t\t}\n\t\t\t} else if (ext === '.css') {\n\t\t\t\tif (!_h.perResourceSriHashes.styles.has(relativePath)) {\n\t\t\t\t\tconst sriHash = generateSRIHash(await readFile(_filePath))\n\t\t\t\t\t_h.extStyleHashes.add(sriHash)\n\t\t\t\t\t_h.perResourceSriHashes.styles.set(relativePath, sriHash)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_filePath => ['.js', '.mjs', '.css'].includes(extname(_filePath)),\n\t)\n}\n\nexport const scanAllowLists = async (\n\tsri: Pick<SRIOptions, 'scriptsAllowListUrls' | 'stylesAllowListUrls'>,\n\th: HashesCollection,\n): Promise<void> => {\n\tfor (const scriptUrl of sri.scriptsAllowListUrls ?? []) {\n\t\tconst resourceResponse = await fetch(scriptUrl, { method: 'GET' })\n\t\tconst resourceContent = await resourceResponse.arrayBuffer()\n\t\tconst sriHash = generateSRIHash(resourceContent)\n\n\t\th.extScriptHashes.add(sriHash)\n\t\th.perResourceSriHashes.scripts.set(scriptUrl, sriHash)\n\t}\n\n\tfor (const styleUrl of sri.stylesAllowListUrls ?? []) {\n\t\tconst resourceResponse = await fetch(styleUrl, { method: 'GET' })\n\t\tconst resourceContent = await resourceResponse.arrayBuffer()\n\t\tconst sriHash = generateSRIHash(resourceContent)\n\n\t\th.extStyleHashes.add(sriHash)\n\t\th.perResourceSriHashes.styles.set(styleUrl, sriHash)\n\t}\n}\n\n// TODO: TEST CASE!\nexport async function generateSRIHashesModule(\n\tlogger: Logger,\n\th: HashesCollection,\n\tsriHashesModule: string,\n\tenableMiddleware_SRI: boolean,\n): Promise<void> {\n\tlet extResourceHashesChanged = false\n\tlet persistHashes = false\n\n\tconst inlineScriptHashes = Array.from(h.inlineScriptHashes).sort()\n\tconst inlineStyleHashes = Array.from(h.inlineStyleHashes).sort()\n\tconst extScriptHashes = Array.from(h.extScriptHashes).sort()\n\tconst extStyleHashes = Array.from(h.extStyleHashes).sort()\n\tconst perPageHashes: Record<string, { scripts: string[]; styles: string[] }> =\n\t\t{}\n\n\tfor (const [k, v] of h.perPageSriHashes.entries()) {\n\t\tperPageHashes[k] = {\n\t\t\tscripts: Array.from(v.scripts).sort(),\n\t\t\tstyles: Array.from(v.styles).sort(),\n\t\t}\n\t}\n\n\tconst perResourceHashes: {\n\t\tscripts: Record<string, string>\n\t\tstyles: Record<string, string>\n\t} = { scripts: {}, styles: {} }\n\n\tfor (const [k, v] of h.perResourceSriHashes.scripts.entries()) {\n\t\tperResourceHashes.scripts[k] = v\n\t}\n\n\tfor (const [k, v] of h.perResourceSriHashes.styles.entries()) {\n\t\tperResourceHashes.styles[k] = v\n\t}\n\n\tif (await doesFileExist(sriHashesModule)) {\n\t\tconst hModule: HashesModule = await import(\n\t\t\t/* @vite-ignore */ sriHashesModule\n\t\t)\n\n\t\textResourceHashesChanged = !sriHashesEqual(\n\t\t\tperResourceHashes,\n\t\t\thModule.perResourceSriHashes ?? { scripts: {}, styles: {} },\n\t\t)\n\t\tpersistHashes =\n\t\t\textResourceHashesChanged ||\n\t\t\t!arraysEqual(inlineScriptHashes, hModule.inlineScriptHashes ?? []) ||\n\t\t\t!arraysEqual(inlineStyleHashes, hModule.inlineStyleHashes ?? []) ||\n\t\t\t!arraysEqual(extScriptHashes, hModule.extScriptHashes ?? []) ||\n\t\t\t!arraysEqual(extStyleHashes, hModule.extStyleHashes ?? []) ||\n\t\t\t!pageHashesEqual(perPageHashes, hModule.perPageSriHashes ?? {})\n\t} else {\n\t\tpersistHashes = true\n\t}\n\n\tif (persistHashes) {\n\t\tif (extResourceHashesChanged && enableMiddleware_SRI) {\n\t\t\tlogger.warn(\n\t\t\t\t'SRI hashes have changed for static resources that may be used in dynamic pages. You should run the build step again',\n\t\t\t)\n\t\t}\n\n\t\tlet hashesFileContent = '// Do not edit this file manually\\n\\n'\n\t\thashesFileContent += `export const inlineScriptHashes = /** @type {string[]} */ ([${inlineScriptHashes\n\t\t\t.map(h => `\\n\\t'${h}',`)\n\t\t\t.join('')}${inlineScriptHashes.length > 0 ? '\\n' : ''}])\\n\\n`\n\t\thashesFileContent += `export const inlineStyleHashes = /** @type {string[]} */ ([${inlineStyleHashes\n\t\t\t.map(h => `\\n\\t'${h}',`)\n\t\t\t.join('')}${inlineStyleHashes.length > 0 ? '\\n' : ''}])\\n\\n`\n\t\thashesFileContent += `export const extScriptHashes = /** @type {string[]} */ ([${extScriptHashes\n\t\t\t.map(h => `\\n\\t'${h}',`)\n\t\t\t.join('')}${extScriptHashes.length > 0 ? '\\n' : ''}])\\n\\n`\n\t\thashesFileContent += `export const extStyleHashes = /** @type {string[]} */ ([${extStyleHashes\n\t\t\t.map(h => `\\n\\t'${h}',`)\n\t\t\t.join('')}${extStyleHashes.length > 0 ? '\\n' : ''}])\\n\\n`\n\t\thashesFileContent += `export const perPageSriHashes =\\n\\t/** @type {Record<string, { scripts: string[]; styles: string [] }>} */ ({${Object.entries(\n\t\t\tperPageHashes,\n\t\t)\n\t\t\t.sort()\n\t\t\t.map(\n\t\t\t\t([k, v]) =>\n\t\t\t\t\t`\\n\\t\\t'${k}': {\\n\\t\\t\\tscripts: [${v.scripts\n\t\t\t\t\t\t.map(h => `\\n\\t\\t\\t\\t'${h}',`)\n\t\t\t\t\t\t.join('')}${\n\t\t\t\t\t\tv.scripts.length > 0 ? '\\n\\t\\t\\t' : ''\n\t\t\t\t\t}],\\n\\t\\t\\tstyles: [${v.styles\n\t\t\t\t\t\t.map(h => `\\n\\t\\t\\t\\t'${h}',`)\n\t\t\t\t\t\t.join('')}${v.styles.length > 0 ? '\\n\\t\\t\\t' : ''}],\\n\\t\\t}`,\n\t\t\t)\n\t\t\t.join(',')}}\\n)\\n\\n`\n\t\thashesFileContent += `export const perResourceSriHashes = {\\n\\tscripts: /** @type {Record<string,string>} */ ({\\n${Object.entries(\n\t\t\tperResourceHashes.scripts,\n\t\t)\n\t\t\t.map(([k, v]) => `\\t\\t'${k}': '${v}',\\n`)\n\t\t\t.join(\n\t\t\t\t'',\n\t\t\t)}\\t}),\\n\\tstyles: /** @type {Record<string,string>} */ ({\\n${Object.entries(\n\t\t\tperResourceHashes.styles,\n\t\t)\n\t\t\t.map(([k, v]) => `\\t\\t'${k}': '${v}',\\n`)\n\t\t\t.join('')}\\t}),\\n}\\n`\n\n\t\tawait mkdir(dirname(sriHashesModule), { recursive: true })\n\t\tawait writeFile(sriHashesModule, hashesFileContent)\n\t}\n}\n\nconst newHashesCollection = (): HashesCollection => ({\n\tinlineScriptHashes: new Set(),\n\tinlineStyleHashes: new Set(),\n\textScriptHashes: new Set(),\n\textStyleHashes: new Set(),\n\tperPageSriHashes: new Map(),\n\tperResourceSriHashes: {\n\t\tscripts: new Map(),\n\t\tstyles: new Map(),\n\t},\n})\n\n// TODO: TEST CASE!\nexport const processStaticFiles = async (\n\tlogger: Logger,\n\t{ state, distDir, sri, securityHeaders }: StrictShieldOptions,\n): Promise<void> => {\n\tconst h = newHashesCollection()\n\n\tawait scanAllowLists(sri, h)\n\tawait scanForNestedResources(logger, distDir, h)\n\tawait scanDirectory(\n\t\tlogger,\n\t\tdistDir,\n\t\tdistDir,\n\t\th,\n\t\tprocessHTMLFile,\n\t\tfile => extname(file) === '.html',\n\t\tsri,\n\t\tstate,\n\t)\n\n\tif (securityHeaders?.enableOnStaticPages !== undefined) {\n\t\tconst provider = securityHeaders.enableOnStaticPages.provider\n\t\tswitch (provider) {\n\t\t\tcase 'netlify': {\n\t\t\t\tawait patchNetlifyHeadersConfig(\n\t\t\t\t\tresolve(distDir, '_headers'),\n\t\t\t\t\tsecurityHeaders,\n\t\t\t\t\th.perPageSriHashes,\n\t\t\t\t)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'vercel': {\n\t\t\t\tawait patchVercelHeadersConfig(\n\t\t\t\t\tlogger,\n\t\t\t\t\tdistDir,\n\t\t\t\t\tstate.config,\n\t\t\t\t\tsecurityHeaders,\n\t\t\t\t\th.perPageSriHashes,\n\t\t\t\t)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\texhaustiveGuard(provider, 'provider')\n\t\t}\n\t}\n\n\tif (sri.hashesModule) {\n\t\tawait generateSRIHashesModule(\n\t\t\tlogger,\n\t\t\th,\n\t\t\tsri.hashesModule,\n\t\t\tsri.enableMiddleware,\n\t\t)\n\t}\n}\n\nexport const getMiddlewareHandler = (\n\tlogger: Logger,\n\tglobalHashes: MiddlewareHashes,\n\tsri: Required<SRIOptions>,\n): MiddlewareHandler => {\n\treturn (async (_ctx, next) => {\n\t\tconst response = await next()\n\t\tconst content = await response.text()\n\n\t\tconst { updatedContent } = updateDynamicPageSriHashes(\n\t\t\tlogger,\n\t\t\tcontent,\n\t\t\tglobalHashes,\n\t\t\tsri,\n\t\t)\n\n\t\tconst patchedResponse = new Response(updatedContent, {\n\t\t\tstatus: response.status,\n\t\t\tstatusText: response.statusText,\n\t\t\theaders: response.headers,\n\t\t})\n\t\treturn patchedResponse\n\t}) satisfies MiddlewareHandler\n}\n\n/**\n * Variant of `getMiddlewareHandler` that also applies security headers.\n */\nexport const getCSPMiddlewareHandler = (\n\tlogger: Logger,\n\tglobalHashes: MiddlewareHashes,\n\tsecurityHeadersOpts: SecurityHeadersOptions,\n\tsri: Required<SRIOptions>,\n): MiddlewareHandler => {\n\treturn (async (_ctx, next) => {\n\t\tconst response = await next()\n\t\tconst content = await response.text()\n\n\t\tconst { updatedContent, pageHashes } = updateDynamicPageSriHashes(\n\t\t\tlogger,\n\t\t\tcontent,\n\t\t\tglobalHashes,\n\t\t\tsri,\n\t\t)\n\n\t\tconst patchedResponse = new Response(updatedContent, {\n\t\t\tstatus: response.status,\n\t\t\tstatusText: response.statusText,\n\t\t\theaders: patchHeaders(response.headers, pageHashes, securityHeadersOpts),\n\t\t})\n\t\treturn patchedResponse\n\t}) satisfies MiddlewareHandler\n}\n\nconst middlewareVirtualModuleId = 'virtual:@kindspells/astro-shield/middleware'\nconst resolvedMiddlewareVirtualModuleId = `\\0${middlewareVirtualModuleId}`\n\nconst loadVirtualMiddlewareModule = async (\n\tlogger: Logger,\n\tsri: Required<SRIOptions>,\n\tsecurityHeadersOptions: SecurityHeadersOptions | undefined,\n\tpublicDir: string,\n): Promise<string> => {\n\tlet extraImports = ''\n\tlet staticHashesModuleLoader = ''\n\n\tif (sri.enableStatic && sri.hashesModule) {\n\t\tlet shouldRegenerateHashesModule = !(await doesFileExist(sri.hashesModule))\n\n\t\tif (!shouldRegenerateHashesModule) {\n\t\t\ttry {\n\t\t\t\tconst hashesModule: HashesModule = await import(\n\t\t\t\t\t/* @vite-ignore */ sri.hashesModule\n\t\t\t\t)\n\n\t\t\t\tfor (const allowedScript of sri.scriptsAllowListUrls) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!Object.hasOwn(\n\t\t\t\t\t\t\thashesModule.perResourceSriHashes.scripts,\n\t\t\t\t\t\t\tallowedScript,\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tshouldRegenerateHashesModule = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Failed to load SRI hashes module \"${sri.hashesModule}\", it will be re-generated:\\n\\t${err}`,\n\t\t\t\t)\n\t\t\t\tshouldRegenerateHashesModule = true\n\t\t\t}\n\t\t}\n\n\t\tif (shouldRegenerateHashesModule) {\n\t\t\tconst h = newHashesCollection()\n\n\t\t\t// We generate a provisional hashes module. It won't contain the hashes for\n\t\t\t// resources created by Astro, but it can be useful nonetheless.\n\t\t\tawait scanForNestedResources(logger, publicDir, h)\n\t\t\tawait scanAllowLists(sri, h)\n\t\t\tawait generateSRIHashesModule(\n\t\t\t\tlogger,\n\t\t\t\th,\n\t\t\t\tsri.hashesModule,\n\t\t\t\tfalse, // So we don't get redundant warnings\n\t\t\t)\n\t\t}\n\t}\n\n\tif (\n\t\tsri.enableStatic &&\n\t\tsri.hashesModule &&\n\t\t(await doesFileExist(sri.hashesModule))\n\t) {\n\t\textraImports = `import { perResourceSriHashes } from '${sri.hashesModule}'`\n\t\tstaticHashesModuleLoader = `\ntry {\n\tif (perResourceSriHashes) {\n\t\tfor (const [key, value] of Object.entries(\n\t\t\tperResourceSriHashes.scripts ?? {},\n\t\t)) {\n\t\t\tglobalHashes.scripts.set(key, value)\n\t\t}\n\t\tfor (const [key, value] of Object.entries(\n\t\t\tperResourceSriHashes.styles ?? {},\n\t\t)) {\n\t\t\tglobalHashes.styles.set(key, value)\n\t\t}\n\t}\n} catch (err) {\n\tconsole.error('Failed to load static hashes module:', err)\n}\n`\n\t} else if (sri.enableStatic && sri.hashesModule) {\n\t\t// Highly unlikely that this happens because of the provisional hashes\n\t\t// module, but the world is a strange place.\n\t\tlogger.warn(\n\t\t\t`The SRI hashes module \"${sri.hashesModule}\" did not exist at build time. You may have to run the build step again`,\n\t\t)\n\t}\n\n\treturn `\nimport { defineMiddleware } from 'astro/middleware'\nimport { getGlobalHashes } from '@kindspells/astro-shield/state'\nimport { ${\n\t\tsecurityHeadersOptions !== undefined\n\t\t\t? 'getCSPMiddlewareHandler'\n\t\t\t: 'getMiddlewareHandler'\n\t} } from '@kindspells/astro-shield/core'\n${extraImports}\n\nexport const onRequest = await (async () => {\n\tconst globalHashes = await getGlobalHashes()\n\n\t${staticHashesModuleLoader}\n\n\treturn defineMiddleware(${\n\t\tsecurityHeadersOptions !== undefined\n\t\t\t? `getCSPMiddlewareHandler(console, globalHashes, ${JSON.stringify(\n\t\t\t\t\tsecurityHeadersOptions,\n\t\t\t\t)}, ${JSON.stringify(sri)})`\n\t\t\t: `getMiddlewareHandler(console, globalHashes, ${JSON.stringify(sri)})`\n\t})\n})()\n`\n}\n\n/** @internal */\nexport const getViteMiddlewarePlugin = (\n\tlogger: Logger,\n\tsri: Required<SRIOptions>,\n\tsecurityHeaders: SecurityHeadersOptions | undefined,\n\tpublicDir: string,\n): Plugin => {\n\treturn {\n\t\tname: 'vite-plugin-astro-shield',\n\t\tresolveId(id) {\n\t\t\tif (id === middlewareVirtualModuleId) {\n\t\t\t\treturn resolvedMiddlewareVirtualModuleId\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t\tasync load(id, _options) {\n\t\t\tswitch (id) {\n\t\t\t\tcase resolvedMiddlewareVirtualModuleId:\n\t\t\t\t\treturn await loadVirtualMiddlewareModule(\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tsri,\n\t\t\t\t\t\tsecurityHeaders,\n\t\t\t\t\t\tpublicDir,\n\t\t\t\t\t)\n\t\t\t\tdefault:\n\t\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\nexport const getAstroBuildDone = (\n\tstate: IntegrationState,\n\tsri: Required<SRIOptions>,\n\tsecurityHeaders: SecurityHeadersOptions | undefined,\n): NonNullable<AstroHooks['astro:build:done']> =>\n\t(async ({ dir, logger }) => {\n\t\tif (sri.enableStatic) {\n\t\t\tawait processStaticFiles(logger, {\n\t\t\t\tstate,\n\t\t\t\tdistDir: fileURLToPath(dir),\n\t\t\t\tsri,\n\t\t\t\tsecurityHeaders,\n\t\t\t})\n\t\t}\n\t}) satisfies NonNullable<AstroHooks['astro:build:done']>\n\n/**\n * @param {Required<SRIOptions>} sri\n * @param {SecurityHeadersOptions | undefined} securityHeaders\n * @returns\n */\nexport const getAstroConfigSetup = (\n\tstate: IntegrationState,\n\tsri: Required<SRIOptions>,\n\tsecurityHeaders: SecurityHeadersOptions | undefined,\n): Required<AstroIntegration['hooks']>['astro:config:setup'] => {\n\t// biome-ignore lint/suspicious/useAwait: We have to conform to the Astro API\n\treturn async ({ logger, addMiddleware, config, updateConfig }) => {\n\t\tstate.config = config\n\n\t\tif (sri.enableMiddleware) {\n\t\t\tconst publicDir = fileURLToPath(config.publicDir)\n\t\t\tconst plugin = getViteMiddlewarePlugin(\n\t\t\t\tlogger,\n\t\t\t\tsri,\n\t\t\t\tsecurityHeaders,\n\t\t\t\tpublicDir,\n\t\t\t)\n\t\t\tupdateConfig({ vite: { plugins: [plugin] } })\n\n\t\t\taddMiddleware({\n\t\t\t\torder: 'post',\n\t\t\t\tentrypoint: 'virtual:@kindspells/astro-shield/middleware',\n\t\t\t})\n\t\t}\n\n\t\tif (state.delayTransform) {\n\t\t\tupdateConfig({\n\t\t\t\tintegrations: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: '@kindspells/astro-shield-post-config-setup',\n\t\t\t\t\t\thooks: {\n\t\t\t\t\t\t\t'astro:build:done': getAstroBuildDone(\n\t\t\t\t\t\t\t\tstate,\n\t\t\t\t\t\t\t\tsri,\n\t\t\t\t\t\t\t\tsecurityHeaders,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t})\n\t\t}\n\t}\n}\n"],"names":["doesFileExist","__name","path","stat","err","scanDirectory","logger","currentPath","rootPath","h","processFile","filenameCondition","sri","state","file","readdir","filePath","resolve","stats","serialiseHashes","hashes","serializeCspDirectiveSources","serialiseCspDirectives","directives","k","v","setSrcDirective","srcType","baseSrcDirective","srcDirective","spacesRegex","hash","cspSplitterRegex","parseCspDirectives","cspHeader","directive","parts","patchCspHeader","plainHeaders","pageHashes","cspOpts","patchHeaders","headers","securityHeadersOpts","headerRegex","commentRegex","tryToInitializePathConfig","lineNum","line","ctx","pushComment","match","pushHeader","pushEntry","pushLine","processPathLine","parseNetlifyHeadersConfig","config","readNetlifyHeadersFile","readFile","serializeNetlifyHeadersConfig","indent","result","entry","e","compareConfigEntries","a","b","comparePathEntries","comparePathEntriesSimplified","buildNetlifyHeadersConfig","securityHeadersOptions","perPageSriHashes","pagesToIterate","page","pathEntries","mergeNetlifyPathHeaders","base","patch","merged","baseIndex","patchIndex","baseEntry","patchEntry","mergeNetlifyHeadersConfig","indentWith","baseEntries","patchEntries","mergedEntries","patchNetlifyHeadersConfig","configPath","baseConfig","patchConfig","mergedConfig","writeFile","exhaustiveGuard","_v","caseName","vercelAdapterDistRegexp","parseVercelConfig","parsed","readVercelConfigFile","buildVercelConfig","astroConfig","indexSlashOffset","routes","mergeVercelConfig","serializeVercelConfig","patchVercelHeadersConfig","distDir","generateSRIHash","data","createHash","scriptReplacer","attrs","setCrossorigin","content","styleReplacer","linkStyleReplacer","urlLikeRegex","anonymousCrossOriginRegex","integrityRegex","relStylesheetRegex","naiveAttrSplitter","extractIntegrityHash","attr","m","regexProcessors","updateStaticPageSriHashes","relativeFilepath","allowInlineScripts","allowInlineStyles","updatedContent","attrsRegex","hasContent","regex","srcRegex","replacer","t","t2","_elemContent","elemContent","sriHash","srcMatch","src","givenSriHash","cachedHash","resourceContent","updatedSrc","resourcePath","hasAnonymousCrossOrigin","updateDynamicPageSriHashes","globalHashes","globalHash","processHTMLFile","relative","arraysEqual","i","pageHashesEqual","aKeys","bKeys","aKey","aValue","bValue","sriHashesEqual","aScriptsKeys","bScriptsKeys","aStylesKeys","bStylesKeys","scanForNestedResources","dirPath","_logger","_filePath","_distDir","_h","relativePath","ext","extname","scanAllowLists","scriptUrl","styleUrl","generateSRIHashesModule","sriHashesModule","enableMiddleware_SRI","extResourceHashesChanged","persistHashes","inlineScriptHashes","inlineStyleHashes","extScriptHashes","extStyleHashes","perPageHashes","perResourceHashes","hModule","hashesFileContent","mkdir","dirname","newHashesCollection","processStaticFiles","securityHeaders","provider","getMiddlewareHandler","_ctx","next","response","getCSPMiddlewareHandler","middlewareVirtualModuleId","resolvedMiddlewareVirtualModuleId","loadVirtualMiddlewareModule","publicDir","extraImports","staticHashesModuleLoader","shouldRegenerateHashesModule","hashesModule","allowedScript","getViteMiddlewarePlugin","id","_options","getAstroBuildDone","dir","fileURLToPath","getAstroConfigSetup","addMiddleware","updateConfig","plugin"],"mappings":";;;;;;;AAiBO,MAAMA,IAAgBC,gBAAAA,EAAA,OAAOC,MAAmC;AAClE,MAAA;AACGC,WAAAA,MAAAA,EAAKD,CAAI,GACR;AAAA,WACCE,GAAK;AACb,QAAKA,GAAuC,SAAS;AAC7C,aAAA;AAEFA,UAAAA;AAAAA,EAAA;AAER,GAV6B,eAahB,GAAAC,IAAgBJ,gBAAAA,EAAA,OAC5BK,GACAC,GACAC,GACAC,GACAC,GAQAC,GACAC,GACAC,MACmB;AACnB,aAAWC,KAAQ,MAAMC,EAAQR,CAAW,GAAG;AACxCS,UAAAA,IAAWC,EAAQV,GAAaO,CAAI,GACpCI,IAAQ,MAAMf,EAAKa,CAAQ;AAE7BE,IAAAA,EAAM,YAAY,IACrB,MAAMb;AAAA,MACLC;AAAAA,MACAU;AAAAA,MACAR;AAAAA,MACAC;AAAAA,MACAC;AAAAA,MACAC;AAAAA,MACAC;AAAAA,MACAC;AAAAA,IAESK,IAAAA,EAAM,OAAO,KAAKP,EAAkBG,CAAI,KAClD,MAAMJ,EAAYJ,GAAQU,GAAUR,GAAUC,GAAGG,GAAKC,CAAK;AAAA,EAAA;AAG9D,GApC6B,eAAA;;ACvBtB,MAAMM,KAAkBlB,gBAAAA,EAAA,CAACmB,MAC/B,MAAM,KAAKA,CAAM,EACf,KAAK,EACL,IAAI,CAAAX,MAAK,IAAIA,CAAC,GAAG,EACjB,KAAK,GAAG,GAJoB,iBAAA,GAMlBY,KAA+BpB,gBAAAA,EAAA,CAACmB,MAC5C,MAAM,KAAKA,CAAM,EAAE,KAAA,EAAO,KAAK,GAAG,GADS,8BAAA,GAG/BE,IAAyBrB,gBAAAA,EAAA,CAACsB,MACtC,OAAO,QAAQA,CAAU,EACvB,KAAK,EACL,IAAI,CAAC,CAACC,GAAGC,CAAC,MAAM,GAAGD,CAAC,IAAIC,CAAC,EAAE,EAC3B,KAAK,IAAI,GAJ0B,wBAAA,GAMzBC,IAAkBzB,gBAAAA,EAAA,CAC9BsB,GACAI,GACAP,MACU;AACJQ,QAAAA,IAAmBL,EAAWI,CAAO;AAC3C,MAAIC,GAAkB;AACrB,UAAMC,IAAe,IAAI,IAAID,EAAiB,MAAME,EAAW,CAAC;AAChE,eAAWC,KAAQX;AAClBS,MAAAA,EAAa,IAAI,IAAIE,CAAI,GAAG;AAE7BR,IAAAA,EAAWI,CAAO,IAAIN,GAA6BQ,CAAY;AAAA,EAChE;AACCN,IAAAA,EAAWI,CAAO,IAAI,UAAUR,GAAgBC,CAAM,CAAC;AAEzD,GAf+B,iBAAA,GAiBzBY,KAAmB,SACnBF,KAAc,QAEPG,KAAqBhC,gBAAAA,EAAA,CAACiC,MAC3BA,IACJ,OAAO;AAAA,EACPA,EACE,MAAMF,EAAgB,EACtB,OAAO,CAAAP,MAAK,CAAC,CAACA,CAAC,EACf,IAAI,CAAAU,MAAa;AAEjB,UAAMC,IAAQD,EACZ,QAAQL,IAAa,QAAQ,EAC7B,MAAM,QAAQ;AAChB,WAAO,CAACM,EAAM,CAAC,GAAwBA,EAAM,CAAC,KAAK,EAAE;AAAA,EAAA,CAIrD,KAAK,CAAA;AACR,IACC,IAjB8B,oBAoBrB,GAAAC,KAAiBpC,gBAAAA,EAAA,CAC7BqC,GACAC,GACAC,MACU;AACV,QAAMjB,IAAa,OAAO,OAAOe,GAAc,yBAAyB,IACrE;AAAA,IACA,GAAGE,EAAQ;AAAA,IACX,GAAGP;AAAA,MACFK,EAAa,yBAAyB;AAAA,IAAA;AAAA,EACvC,IAECE,EAAQ,iBAAkB,CAAC;AAE3BD,EAAAA,EAAW,QAAQ,OAAO,IAC7Bb,EAAgBH,GAAY,cAAcgB,EAAW,OAAO,IAE5DhB,EAAW,YAAY,IAAI,UAExBgB,EAAW,OAAO,OAAO,IAC5Bb,EAAgBH,GAAY,aAAagB,EAAW,MAAM,IAE1DhB,EAAW,WAAW,IAAI,UAEvB,OAAO,KAAKA,CAAU,EAAE,SAAS,MACpCe,EAAa,yBAAyB,IAAIhB,EAAuBC,CAAU;AAE7E,GA3B8B,mBA6BjBkB,KAAexC,gBAAAA,EAAA,CAC3ByC,GACAH,GACAI,MACa;AACb,QAAML,IAAe,OAAO,YAAYI,EAAQ,SAAS;AAErDC,SAAAA,EAAoB,0BAA0B,UACjDN;AAAA,IACCC;AAAAA,IACAC;AAAAA,IACAI,EAAoB;AAAA,EAAA,GAIf,IAAI,QAAQL,CAAY;AAChC,GAhB4B,cAAA;;AC3D5B,MAAMR,KAAc,QACdc,KACL,+DACKC,KAAe,oCAQfC,IAA4B7C,gBAAAA,EAAA,CACjC8C,GACAC,GACAC,MACU;AACV,MAAID,MAAS;AACZC,IAAAA,EAAI,QAAQ,KAAKD,CAAI;AAAA,WACXA,EAAK,WAAW,GAAG;AAC7BC,IAAAA,EAAI,QAAQ,KAAK,EAAE,SAASD,GAAM;AAAA,OAC5B;AAAIlB,QAAAA,GAAY,KAAKkB,CAAI;AAC/B,YAAM,IAAI,MAAM,gCAAgCD,CAAO,GAAG;AAChDC,QAAAA,EAAK,WAAW,GAAG;AAC7BC,MAAAA,EAAI,cAAc,EAAE,MAAMD,GAAM,SAAS,GACzCC,GAAAA,EAAI,QAAQ,KAAKA,EAAI,WAAW;AAAA;AAEhC,YAAM,IAAI,MAAM,oBAAoBF,CAAO,GAAG;AAAA,EAAA;AAEhD,GAjBkC,8BAmB5BG,KAAcjD,gBAAAA,EAAA,CACnB8C,GACAI,GACA5C,MACU;AACN4C,MAAAA,EAAM,QAAQ,YAAY;AAC7B,UAAM,IAAI,MAAM,oBAAoBJ,CAAO,GAAG;AAE/CxC,EAAAA,GAAa,QAAQ,KAAK,EAAE,SAAS4C,EAAM,OAAO,SAAS;AAC5D,GAToB,gBAWdC,KAAanD,gBAAAA,EAAA,CAClB8C,GACAI,GACA5C,MACU;AACV,MAAI4C,EAAM,QAAQ,SAAS,UAAaA,EAAM,QAAQ,UAAU;AAC/D,UAAM,IAAI,MAAM,oBAAoBJ,CAAO,GAAG;AAG/CxC,EAAAA,GAAa,QAAQ,KAAK;AAAA,IACzB,KAAK4C,EAAM,OAAO;AAAA,IAClB,OAAOA,EAAM,OAAO;AAAA,EAAA,CACpB;AACF,GAbmB,YAAA,GAebE,IAAYpD,gBAAAA,EAAA,CACjBkD,GACAJ,GACAC,GACAM,GAKAL,MACU;AACNA,MAAAA,EAAI,eAAe,QAAW;AAC7BE,QAAAA,EAAM,QAAQ,WAAW;AAC5B,YAAM,IAAI,MAAM,oBAAoBJ,CAAO,GAAG;AAE3CI,QAAAA,EAAM,QAAQ,WAAW;AAC5B,YAAM,IAAI,MAAM,qCAAqCJ,CAAO,GAAG;AAEhEE,IAAAA,EAAI,aAAaE,EAAM,QAAQ;AAAA,EAAA;AAG5BA,MAAAA,EAAM,QAAQ,WAAW,IAAI;AAChC,SAAKF,EAAI,aAAa,QAAQ,UAAU,OAAO;AAC9C,YAAM,IAAI,MAAM,oBAAoBF,CAAO,GAAG;AAE/CE,IAAAA,EAAI,cAAc,QAClBH,EAA0BC,GAASC,GAAMC,CAAG;AAAA,EAAA,OACtC;AAAIE,QAAAA,EAAM,QAAQ,WAAWF,EAAI;AACvC,YAAM,IAAI,MAAM,gCAAgCF,CAAO,GAAG;AAE1DO,IAAAA,EAASP,GAASI,GAAOF,EAAI,WAAW;AAAA,EAAA;AAE1C,GAhCkB,cAkCZM,KAAkBtD,gBAAAA,EAAA,CACvB8C,GACAC,GACAC,MACU;AACV,MAAIE,IAAiC;AAGhCA,MAAAA,IAAQN,GAAa,KAAKG,CAAI;AAClCK,IAAAA,EAAUF,GAAOJ,GAASC,GAAME,IAAaD,CAAG;AAAA,WAGvCE,IAAQP,GAAY,KAAKI,CAAI;AACtCK,IAAAA,EAAUF,GAAOJ,GAASC,GAAMI,IAAYH,CAAG;AAAA,WACrC,CAACnB,GAAY,KAAKkB,CAAI,GAAG;AACnC,SAAKC,EAAI,aAAa,QAAQ,UAAU,OAAO;AAC9C,YAAM,IAAI,MAAM,oBAAoBF,CAAO,GAAG;AAE/CE,IAAAA,EAAI,cAAc,QAClBH,EAA0BC,GAASC,GAAMC,CAAG;AAAA,EAAA;AAE9C,GArBwB,iBAAA,GAuBXO,KAA4BvD,gBAAAA,EAAA,CACxCwD,MAC6B;AAC7B,QAAMR,IAAoB;AAAA,IACzB,YAAY;AAAA,IACZ,SAAS,CAAC;AAAA,IACV,aAAa;AAAA,EACd;AAEA,aAAW,CAACF,GAASC,CAAI,KAAKS,EAAO,MAAM;AAAA,CAAI,EAAE,QAAQ;AACpDR,MAAI,gBAAgB,SACvBH,EAA0BC,GAASC,GAAMC,CAAG,IAE5CM,GAAgBR,GAASC,GAAMC,CAAG;AAI7B,SAAA;AAAA,IACN,YAAYA,EAAI,cAAc;AAAA,IAC9B,SAASA,EAAI,QAAQ,GAAG,EAAE,MAAM,KAAKA,EAAI,QAAQ,MAAM,GAAG,EAAE,IAAIA,EAAI;AAAA,EACrE;AACD,GArByC,8BAuB5BS,KAAyBzD,gBAAAA,EAAA,OACrCC,MAEOsD,GAA0B,MAAMG,EAASzD,GAAM,MAAM,CAAC,GAHxB,wBAAA,GAMzB0D,KAAgC3D,gBAAAA,EAAA,CAC5CwD,MACY;AACZ,QAAMI,IAASJ,EAAO;AACtB,MAAIK,IAAS;AAEb,aAAWC,KAASN,EAAO;AACtBM,IAAAA,MAAU,KACbD,KAAU;AAAA,IACA,aAAaC,IACvBD,KAAU,GAAGC,EAAM,OAAO;AAAA,IAChB,UAAUA,MACpBD,KAAU,GAAGC,EAAM,IAAI;AAAA,EAAKA,EAAM,QAChC;AAAA,MAAI,CAAAC,MACJ,aAAaA,IACV,GAAGH,CAAM,GAAGG,EAAE,OAAO,KACrB,GAAGH,CAAM,GAAGG,EAAE,GAAG,KAAKA,EAAE,KAAK;AAAA,MAEhC,KAAK;AAAA,CAAI,CAAC;AAAA;AAIPF,SAAAA;AACR,GAvB6C,+BAAA,GAyBvCG,IAAuBhE,gBAAAA,EAAA,CAC5BiE,GACAC,MAGOD,MAAM,MAAMC,MAAM,MAAM,aAAaD,KAAK,aAAaC,IAC3D,IACAD,EAAE,OAAOC,EAAE,OACV,KACAD,EAAE,OAAOC,EAAE,OACV,IACA,GAXuB,sBAAA,GAehBC,KAAqBnE,gBAAAA,EAAA,CACjCiE,GACAC,MAGO,aAAaD,KAAK,aAAaC,IACnC,IACAD,EAAE,MAAMC,EAAE,MACT,KACAD,EAAE,MAAMC,EAAE,MACT,IACAD,EAAE,QAAQC,EAAE,QACX,KACAD,EAAE,QAAQC,EAAE,QACX,IACA,GAf0B,oBAmBrB,GAAAE,KAA+BpE,gBAAAA,EAAA,CAC3CiE,GACAC,MAGO,aAAaD,KAAK,aAAaC,IACnC,IACAD,EAAE,MAAMC,EAAE,MACT,KACAD,EAAE,MAAMC,EAAE,MACT,IACA,GAXsC,8BAAA,GAc/BG,KAA4BrE,gBAAAA,EAAA,CACxCsE,GACAC,MAC6B;AAC7B,QAAMf,IAAkC;AAAA,IACvC,YAAY;AAAA,IACZ,SAAS,CAAA;AAAA,EACV,GAEMgB,IAA4C,CAAC;AACnD,aAAW,CAACC,GAAMtD,CAAM,KAAKoD,EAAiB,QAAQ;AACjDE,KAAAA,MAAS,gBAAgBA,EAAK,SAAS,aAAa,MACvDD,EAAe,KAAK,CAACC,EAAK,MAAM,GAAG,GAAG,GAAGtD,CAAM,CAAC,GAEjDqD,EAAe,KAAK,CAACC,GAAMtD,CAAM,CAAC;AAEnCqD,EAAAA,EAAe,KAAK;AAEpB,aAAW,CAACC,GAAMtD,CAAM,KAAKqD,GAAgB;AAC5C,UAAME,IAA8C,CAAC;AAEjDJ,QAAAA,EAAuB,0BAA0B,QAAW;AAC/D,YAAMhD,IACLgD,EAAuB,sBAAsB,iBAAiB,CAAC;AAahE,UAXInD,EAAO,QAAQ,OAAO,IACzBM,EAAgBH,GAAY,cAAcH,EAAO,OAAO,IAExDG,EAAW,YAAY,IAAI,UAExBH,EAAO,OAAO,OAAO,IACxBM,EAAgBH,GAAY,aAAaH,EAAO,MAAM,IAEtDG,EAAW,WAAW,IAAI,UAGvB,OAAO,KAAKA,CAAU,EAAE,WAAW;AACtC;AAGDoD,MAAAA,EAAY,KAAK;AAAA,QAChB,KAAK;AAAA,QACL,OAAOrD,EAAuBC,CAAU;AAAA,MAAA,CACxC;AAAA,IAAA;AAGEoD,IAAAA,EAAY,SAAS,KACxBlB,EAAO,QAAQ,KAAK;AAAA,MACnB,MAAM,IAAIiB,CAAI;AAAA,MACd,SAASC,EAAY,KAAKP,EAAkB;AAAA,IAAA,CAC5C;AAAA,EAAA;AAIIX,SAAAA;AACR,GAvDyC,2BAAA,GAyDnCmB,KAA0B3E,gBAAAA,EAAA,CAC/B4E,GACAC,MACoC;AACpC,QAAMC,IAAyC,CAAC;AAE5CC,MAAAA,IAAY,GACZC,IAAa;AACjB,SAAOD,IAAYH,EAAK,UAAUI,IAAaH,EAAM,UAAQ;AAE5D,UAAMI,IAAYL,EAAKG,CAAS,GAE1BG,IAAaL,EAAMG,CAAU;AAE3B,YAAAZ,GAA6Ba,GAAWC,CAAU,GAAG;AAAA,MAC5D,KAAK,IAAI;AACRJ,QAAAA,EAAO,KAAKG,CAAS,GACrBF,KAAa;AACb;AAAA,MAAA;AAAA,MAED,KAAK,GAAG;AACH,qBAAaG,IAChBF,KAAc,IACJ,aAAaC,KACvBH,EAAO,KAAKG,CAAS,GACrBF,KAAa,MAEbD,EAAO,KAAKI,CAAU,GACtBH,KAAa,GACbC,KAAc;AAEf;AAAA,MAAA;AAAA,MAED,KAAK,GAAG;AACPF,QAAAA,EAAO,KAAKI,CAAU,GACtBF,KAAc;AACd;AAAA,MAAA;AAAA,MAED;AACO,cAAA,IAAI,MAAM,aAAa;AAAA,IAAA;AAAA,EAE/B;AAEMD,SAAAA,IAAYH,EAAK,QAAQG,KAAa;AAE5CD,IAAAA,EAAO,KAAKF,EAAKG,CAAS,CAAE;AAEtBC,SAAAA,IAAaH,EAAM,QAAQG,KAAc;AAE/CF,IAAAA,EAAO,KAAKD,EAAMG,CAAU,CAAE;AAGxBF,SAAAA;AACR,GArDgC,yBAAA,GAuDnBK,KAA4BnF,gBAAAA,EAAA,CACxC4E,GACAC,MAC6B;AACvBO,QAAAA,IAAaR,EAAK,YAClBS,IAAcT,EAAK,QAAQ,MAAA,EAAQ,KAAKZ,CAAoB,GAC5DsB,IAAeT,EAAM,QAAQ,MAAM,EAAE,KAAKb,CAAoB,GAC9DuB,IAAoD,CAAC;AAEvDR,MAAAA,IAAY,GACZC,IAAa;AACjB,SAAOD,IAAYM,EAAY,UAAUL,IAAaM,EAAa,UAAQ;AAE1E,UAAML,IAAYI,EAAYN,CAAS,GAEjCG,IAAaI,EAAaN,CAAU;AAElChB,YAAAA,EAAqBiB,GAAWC,CAAU,GAAG;AAAA,MACpD,KAAK,IAAI;AAGN,eAAOD,KAAc,YACrB,aAAaA,KACbA,EAAU,QAAQ,WAAW,KAI9BM,EAAc,KAAKN,CAAS,GAE7BF,KAAa;AACb;AAAA,MAAA;AAAA,MAED,KAAK,GAAG;AACHG,YAAAA,MAAe,MAAM,aAAaA;AACrCF,UAAAA,KAAc;AAAA,iBACJC,MAAc,MAAM,aAAaA;AAC3CM,UAAAA,EAAc,KAAKL,CAAU,GAC7BF,KAAc;AAAA,iBACJC,EAAU,SAASC,EAAW;AACxCK,UAAAA,EAAc,KAAK;AAAA,YAClB,MAAMN,EAAU;AAAA,YAChB,SAASN;AAAAA,cACRM,EAAU;AAAA,cACVC,EAAW;AAAA,YAAA;AAAA,UAEZ,CAAA,GACDH,KAAa,GACbC,KAAc;AAAA;AAER,gBAAA,IAAI,MAAM,aAAa;AAE9B;AAAA,MAAA;AAAA,MAED,KAAK,GAAG;AAGL,eAAOE,KAAe,YACtB,aAAaA,KACbA,EAAW,QAAQ,WAAW,KAI/BK,EAAc,KAAKL,CAAU,GAE9BF,KAAc;AACd;AAAA,MAAA;AAAA,MAED;AACO,cAAA,IAAI,MAAM,aAAa;AAAA,IAAA;AAAA,EAC/B;AAEMD,SAAAA,IAAYM,EAAY,QAAQN,KAAa;AAEnDQ,IAAAA,EAAc,KAAKF,EAAYN,CAAS,CAAE;AAEpCC,SAAAA,IAAaM,EAAa,QAAQN,KAAc;AAEtDO,IAAAA,EAAc,KAAKD,EAAaN,CAAU,CAAE;AAGtC,SAAA;AAAA,IACN,YAAAI;AAAAA,IACA,SAASG;AAAAA,EACV;AACD,GApFyC,8BAsF5BC,KAA4BxF,gBAAAA,EAAA,OACxCyF,GACAnB,GACAC,MACmB;AACnB,QAAMmB,IAAc,MAAM3F,EAAc0F,CAAU,IAC/C,MAAMhC,GAAuBgC,CAAU,IACvC,EAAE,YAAY,KAAM,SAAS,CAAA,KAE1BE,IAActB;AAAA,IACnBC;AAAAA,IACAC;AAAAA,EAGKqB,GAAAA,IAAeT,GAA0BO,GAAYC,CAAW;AAEtE,QAAME,EAAUJ,GAAY9B,GAA8BiC,CAAY,CAAC;AACxE,GAjByC,2BAAA;;AC5blC,MAAME,KAAkB9F,gBAAAA,GAAA,CAAC+F,GAAWC,MAA2B;AACrE,QAAM,IAAI,MAAM,WAAWA,CAAQ,KAAKD,CAAE,EAAE;AAC7C,GAF+B,iBAAA;;AC0B/B,MAAME,KAA0B,gCAEnBC,KAAoBlG,gBAAAA,EAAA,CAChCK,GACAmD,MACkB;AACZ2C,QAAAA,IAAS,KAAK,MAAM3C,CAAM;AAGhC,MAAI,EAAE,aAAa2C;AACZ,UAAA,IAAI,MAAM,gDAAgD;AAE7DA,SAAAA,EAAO,YAAY,KACtB9F,EAAO;AAAA,IACN,qDAAqD8F,EAAO,OAAO;AAAA,EAAA,GAI9DA;AACR,GAjBiC,mBAAA,GAmBpBC,KAAuBpG,gBAAAA,EAAA,OACnCK,GACAJ,MAEOiG,GAAkB7F,GAAQ,MAAMqD,EAASzD,GAAM,MAAM,CAAC,GAJ1B,sBAOvB,GAAAoG,KAAoBrG,gBAAAA,EAAA,CAChCsG,GACAhC,GACAC,MACkB;AACZgC,QAAAA,IACLD,EAAY,kBAAkB,UAC3B,MACAA,EAAY,kBAAkB,WAC7B,MACA,QAEC9B,IAA4C,CAAC;AACnD,aAAW,CAACC,GAAMtD,CAAM,KAAKoD,EAAiB,QAAQ;AAEpDgC,IAAAA,MAAqB,WACpB9B,MAAS,gBAAgBA,EAAK,SAAS,aAAa,MAErDD,EAAe,KAAK,CAACC,EAAK,MAAM,GAAG8B,CAAgB,GAAGpF,CAAM,CAAC,GAE9DqD,EAAe,KAAK,CAACC,GAAMtD,CAAM,CAAC;AAEnCqD,EAAAA,EAAe,KAAK;AAEpB,QAAMgC,IAAwB,CAAC;AAC/B,aAAW,CAAC/B,GAAMtD,CAAM,KAAKqD,GAAgB;AAC5C,UAAM/B,IAAkC,CAAC;AAErC6B,QAAAA,EAAuB,0BAA0B,QAAW;AAC/D,YAAMhD,IACLgD,EAAuB,sBAAsB,iBAAiB,CAAC;AAahE,UAXInD,EAAO,QAAQ,OAAO,IACzBM,EAAgBH,GAAY,cAAcH,EAAO,OAAO,IAExDG,EAAW,YAAY,IAAI,UAExBH,EAAO,OAAO,OAAO,IACxBM,EAAgBH,GAAY,aAAaH,EAAO,MAAM,IAEtDG,EAAW,WAAW,IAAI,UAGvB,OAAO,KAAKA,CAAU,EAAE,WAAW;AACtC;AAGDmB,QAAQ,yBAAyB,IAAIpB,EAAuBC,CAAU;AAAA,IAAA;AAGnE,WAAO,KAAKmB,CAAO,EAAE,SAAS,KACjC+D,EAAO,KAAK;AAAA,MACX,KAAK,KAAK/B,EAAK,WAAW,KAAK,KAAK,CAAC;AAAA,MACrC,SAAAhC;AAAAA,MACA,UAAU;AAAA,IAAA,CACV;AAAA,EAAA;AAIH,SAAO,EAAE,SAAS,GAAG,QAAA+D,EAAO;AAC7B,GA5DiC,mBAAA,GA8DpBC,KAAoBzG,gBAAAA,EAAA,CAChC4E,GACAC,OAEO,EAAE,GAAGD,GAAM,QAAQ,CAAC,GAAIC,EAAM,UAAU,IAAK,GAAID,EAAK,UAAU,CAAG,CAAA,MAJ1C,mBAAA,GAOpB8B,KAAwB1G,gBAAAA,EAAA,CAACwD,MAC9B,KAAK,UAAUA,GAAQ,MAAM,GAAI,GADJ,uBAAA,GAIxBmD,KAA2B3G,gBAAAA,EAAA,OACvCK,GACAuG,GACAN,GACAhC,GACAC,MACmB;AACnB,MAAI,CAAC0B,GAAwB,KAAKW,CAAO,GAAG;AAC3CvG,IAAAA,EAAO;AAAA,MACN;AAAA,IACD;AACA;AAAA,EAAA;AAED,QAAMoF,IAAazE,EAAQ4F,GAAS,MAAM,aAAa;AACvD,MAAI,CAAE,MAAM7G,EAAc0F,CAAU,GAAI;AACvCpF,IAAAA,EAAO;AAAA,MACN,4DAA4DoF,CAAU;AAAA,IAAA,GAEvEpF,EAAO,MAAM,KAAK,UAAU,MAAMS,EAAQE,EAAQ4F,CAAO,CAAC,CAAC,CAAC,GAC5DvG,EAAO,MAAM,KAAK,UAAU,MAAMS,EAAQE,EAAQ4F,GAAS,IAAI,CAAC,CAAC,CAAC;AAClE;AAAA,EAAA;AAGD,QAAMlB,IAAa,MAAMU,GAAqB/F,GAAQoF,CAAU,GAE1DE,IAAcU;AAAA,IACnBC;AAAAA,IACAhC;AAAAA,IACAC;AAAAA,EAGKqB,GAAAA,IAAea,GAAkBf,GAAYC,CAAW;AAE9D,QAAME,EAAUJ,GAAYiB,GAAsBd,CAAY,CAAC;AAChE,GAlCwC,0BAAA;;ACxFjC,MAAMiB,IAAkB7G,gBAAAA,EAAA,CAC9B8G,MACY;AACNhF,QAAAA,IAAOiF,GAAW,QAAQ;AAC5BD,SAAAA,aAAgB,cACnBhF,EAAK,OAAO,OAAO,KAAKgF,CAAI,CAAC,IACnBA,aAAgB,SAC1BhF,EAAK,OAAOgF,CAAI,IAEhBhF,EAAK,OAAOgF,GAAM,MAAM,GAElB,UAAUhF,EAAK,OAAO,QAAQ,CAAC;AACvC,GAZ+B,iBAAA,GAqBzBkF,KAA+BhH,gBAAAA,EAAA,CAAC8B,GAAMmF,GAAOC,GAAgBC,MAClE,UAAUF,CAAK,eAAenF,CAAI,IACjCoF,IAAiB,6BAA6B,EAC/C,IAAIC,KAAW,EAAE,cAHmB,gBAAA,GAK/BC,KAA8BpH,gBAAAA,EAAA,CAAC8B,GAAMmF,GAAOC,GAAgBC,MACjE,SAASF,CAAK,eAAenF,CAAI,IAChCoF,IAAiB,6BAA6B,EAC/C,IAAIC,KAAW,EAAE,YAHkB,eAAA,GAK9BE,KAAkCrH,gBAAAA,EAAA,CAAC8B,GAAMmF,GAAOC,MACrD,QAAQD,CAAK,eAAenF,CAAI,IAC/BoF,IAAiB,6BAA6B,EAC/C,MAHuC,mBAKlCI,GAAAA,KAAe,wBACfC,KACL,0DACKC,KACL,0GACKC,KACL,oEACKC,KAAoB,kBAEpBC,KAAuB3H,gBAAAA,EAAA,CAACiH,MAAsC;AACxDW,aAAAA,KAAQX,EAAM,MAAMS,EAAiB;AAG3CE,QAAAA,EAAK,UAAU,KAAK;AACjBC,YAAAA,IAAIL,GAAe,KAAKI,CAAI;AAC9BC,UAAAA;AACH,eAAOA,EAAE,QAAQ,cAAcA,EAAE,QAAQ;AAAA,IAAA;AAK7C,GAZ6B,sBAAA,GAchBC,KAAkB;AAAA,EAC9B;AAAA,IACC,GAAG;AAAA,IACH,IAAI;AAAA,IACJ,OACC;AAAA,IACD,UACC;AAAA,IACD,UAAUd;AAAAA,IACV,YAAY;AAAA,IACZ,YAAY;AAAA,EACb;AAAA,EACA;AAAA,IACC,GAAG;AAAA,IACH,IAAI;AAAA,IACJ,OACC;AAAA,IACD,UACC;AAAA;AAAA,IACD,UAAUI;AAAAA,IACV,YAAY;AAAA,IACZ,YAAY;AAAA,EACb;AAAA,EACA;AAAA,IACC,GAAG;AAAA,IACH,IAAI;AAAA,IACJ,OACC;AAAA,IACD,UACC;AAAA,IACD,UAAUC;AAAAA,IACV,YAAY;AAAA,IACZ,YAAYI;AAAAA,EAAA;AAEd,GASaM,KAA4B/H,gBAAAA,EAAA,OACxCK,GACAuG,GACAoB,GACAb,GACA3G,GACAyH,IAA+C,OAC/CC,IAA8C,OAC9CtH,MACqB;AACrB,QAAM0B,IACL9B,EAAE,iBAAiB,IAAIwH,CAAgB,KACtC;AAAA,IACA,6BAAa,IAAI;AAAA,IACjB,4BAAY,IAAI;AAAA,EACjB;AACDxH,EAAAA,EAAE,iBAAiB,IAAIwH,GAAkB1F,CAAU;AAEnD,MAAI6F,IAAiBhB,GACjBjE;AAEO,aAAA;AAAA,IACV,YAAAkF;AAAAA,IACA,YAAAC;AAAAA,IACA,OAAAC;AAAAA,IACA,UAAAC;AAAAA,IACA,UAAAC;AAAAA,IACA,GAAAC;AAAAA,IACA,IAAAC;AAAAA,EAAA,KACIZ;AACJQ,SAAAA,EAAM,YAAY,IAGVpF,IAAQoF,EAAM,KAAKnB,CAAO,OAAO,QAAM;AAC9C,YAAMF,IAAQ/D,EAAM,QAAQ,OAAO,UAAU,IAGvCyF,IAAezF,EAAM,QAAQ,WAAW,IACxC0F,IAAcD,EAAa,WAAW,KAAK,KAAKA;AAEtD,UAAIE,GACA3B,IAAiB;AAErB,UAAID,GAAO;AACV,YAAImB,KAAc,CAACA,EAAW,KAAKnB,CAAK;AACvC;AAGD,cAAM6B,IAAWP,EAAS,KAAKtB,CAAK,GAC9B8B,IACLD,GAAU,QAAQ,QAClBA,GAAU,QAAQ,QAClBA,GAAU,QAAQ,QAClB;AAED,YAAIF,KAAeG,GAAK;AACvB1I,UAAAA,EAAO;AAAA,YACN,GAAGoI,CAAC,KAAKM,CAAG;AAAA,UAAA,GAEbZ,IAAiBA,EAAe,QAAQjF,EAAM,CAAC,GAAG,EAAE;AACpD;AAAA,QAAA;AAGK8F,cAAAA,IAAerB,GAAqBV,CAAK;AAE/C,YAAI+B,MAAiB,QAAW;AAC3BA,UAAAA,MACDF,IAAWtI,EAAE,MAAMiI,CAAC,QAAQ,IAAIjI,EAAE,SAASiI,CAAC,QAAQ,GAAG;AAAA,YACxDO;AAAAA,UAAA,GAED1G,EAAWoG,CAAE,EAAE,IAAIM,CAAY,GAC3BD,KACHvI,EAAE,qBAAqBkI,CAAE,EAAE,IAAIK,GAAKC,CAAY,KAGjD3I,EAAO;AAAA,YACN,uCAAuC2H,CAAgB;AAAA,UACxD;AAED;AAAA,QAAA;AAGD,YAAIe,GAAK;AACR,gBAAME,IAAazI,EAAE,qBAAqBkI,CAAE,EAAE,IAAIK,CAAG;AACjDE,cAAAA;AACHJ,YAAAA,IAAUI,GACVzI,EAAE,MAAMiI,CAAC,QAAQ,EAAE,IAAII,CAAO,GAC9BvG,EAAWoG,CAAE,EAAE,IAAIG,CAAO;AAAA,eACpB;AACFK,gBAAAA;AACA5B,gBAAAA,GAAa,KAAKyB,CAAG;AACxB7B,cAAAA,IAAiB,IAKjBgC,IAAkB,OAJO,MAAM;AAAA,gBAC9BH,EAAI,WAAW,IAAI,IAAI,SAASA,CAAG,KAAKA;AAAAA,gBACxC,EAAE,QAAQ,MAAM;AAAA,iBAEwB,YAAY;AAAA,qBAC3CA,EAAI,WAAW,GAAG,GAAG;AACzBnE,oBAAAA,IAAOhE,GAAO,OAAO,QAAQ,IAC7BuI,KAAaJ,EAAI,WAAWnE,CAAI,IACnCmE,EAAI,QAAQnE,GAAM,EAAE,IACpBmE,GACGK,KAAepI,EAAQ4F,GAAS,IAAIuC,EAAU,EAAE;AACtDD,cAAAA,IAAkB,MAAMxF,EAAS0F,EAAY;AAAA,YAAA,OACvC;AAEN/I,cAAAA,EAAO,KAAK,yCAAyC0I,CAAG,GAAG;AAC3D;AAAA,YAAA;AAGDF,YAAAA,IAAUhC,EAAgBqC,CAAe,GACzC1I,EAAE,MAAMiI,CAAC,QAAQ,EAAE,IAAII,CAAO,GAC9BvG,EAAWoG,CAAE,EAAE,IAAIG,CAAO,GAC1BrI,EAAE,qBAAqBkI,CAAE,EAAE,IAAIK,GAAKF,CAAO;AAAA,UAAA;AAAA,QAC5C;AAAA,MACD;AAGD,UAAIR,KAAc,CAACQ;AAEjB,YAAA,EAAEZ,MAAuB,MAASQ,MAAM,aACxC,EAAEP,MAAsB,MAASO,MAAM;AAEvCI,UAAAA,IAAUhC,EAAgB+B,CAAW,GACrCpI,EAAE,SAASiI,CAAC,QAAQ,EAAE,IAAII,CAAO,GACjCvG,EAAWoG,CAAE,EAAE,IAAIG,CAAO;AAAA,aACpB;AAENxI,UAAAA,EAAO;AAAA,YACN,mBAAmBoI,EAAE,YAAa,CAAA,kBAAkBC,CAAE;AAAA,UAAA,GAEvDP,IAAiBA,EAAe,QAAQjF,EAAM,CAAC,GAAG,EAAE;AACpD;AAAA,QAAA;AAIF,UAAI2F,GAAS;AACNQ,cAAAA,IAA0B9B,GAA0B,KAAKN,CAAK;AAEpEkB,QAAAA,IAAiBA,EAAe;AAAA,UAC/BjF,EAAM,CAAC;AAAA,UACPsF;AAAAA,YACCK;AAAAA,YACA5B,IAAQ,IAAIA,CAAK,KAAK;AAAA,YACtBC,KAAkB,CAACmC;AAAAA,YACnBT;AAAAA,UAAA;AAAA,QAEF;AAAA,MAAA;AAAA,IACD;AAIKT,SAAAA;AACR,GAzJyC,2BAAA,GA2J5BmB,KAA6BtJ,gBAAAA,EAAA,CACzCK,GACA8G,GACAoC,GACA5I,MAC2D;AAC3D,MAAIwH,IAAiBhB,GACjBjE;AAEJ,QAAMZ,IAA4B;AAAA,IACjC,6BAAa,IAAI;AAAA,IACjB,4BAAY,IAAI;AAAA,EACjB;AAEW,aAAA;AAAA,IACV,YAAA8F;AAAAA,IACA,YAAAC;AAAAA,IACA,OAAAC;AAAAA,IACA,UAAAC;AAAAA,IACA,UAAAC;AAAAA,IACA,GAAAC;AAAAA,IACA,IAAAC;AAAAA,EAAA,KACIZ;AACJQ,SAAAA,EAAM,YAAY,IAGVpF,IAAQoF,EAAM,KAAKnB,CAAO,OAAO,QAAM;AAC9C,YAAMF,IAAQ/D,EAAM,QAAQ,OAAO,UAAU,IAGvCyF,IAAezF,EAAM,QAAQ,WAAW,IACxC0F,IAAcD,EAAa,WAAW,KAAK,KAAKA;AAEtD,UAAIE,GACA3B,IAAiB;AAErB,UAAID,GAAO;AAEV,YAAImB,KAAc,CAACA,EAAW,KAAKnB,CAAK;AACvC;AAGD,cAAM6B,IAAWP,EAAS,KAAKtB,CAAK,GAC9B8B,IACLD,GAAU,QAAQ,QAClBA,GAAU,QAAQ,QAClBA,GAAU,QAAQ;AAEnB,YAAIF,KAAeG,GAAK;AACvB1I,UAAAA,EAAO;AAAA,YACN,GAAGoI,CAAC,KAAKM,CAAG;AAAA,UAAA,GAEbZ,IAAiBA,EAAe,QAAQjF,EAAM,CAAC,GAAG,EAAE;AACpD;AAAA,QAAA;AAGK8F,cAAAA,IAAerB,GAAqBV,CAAK;AAE/C,YAAI+B,MAAiB,QAAW;AAC3BA,cAAAA;AACH,gBAAID,GAAK;AACR,oBAAMS,IAAaD,EAAab,CAAE,EAAE,IAAIK,CAAG;AACvCS,cAAAA,IACCA,MAAeR,KAClB3I,EAAO;AAAA,gBACN,kDAAkD0I,CAAG;AAAA,cAAA,GAEtDZ,IAAiBA,EAAe,QAAQjF,EAAM,CAAC,GAAG,EAAE,MAEpD2F,IAAUG,GACV1G,EAAWoG,CAAE,EAAE,IAAIG,CAAO,MAG3BxI,EAAO;AAAA,gBACN,mEAAmE0I,CAAG;AAAA,cAAA,GAEvEZ,IAAiBA,EAAe,QAAQjF,EAAM,CAAC,GAAG,EAAE;AAAA,YAEtD,MAAW0F,CAAAA,MAERF,MAAO,cACN/H,GAAK,sBAAsB,WAAW,SACvC+H,MAAO,aAAa/H,GAAK,qBAAqB,WAAW,SAE1DkI,IAAUG,GACV1G,EAAWoG,CAAE,EAAE,IAAIG,CAAO,MAE1BxI,EAAO;AAAA,cACN,mBAAmBoI,EAAE,YAAa,CAAA,kBAAkBC,CAAE;AAAA,YAAA,GAEvDP,IAAiBA,EAAe,QAAQjF,EAAM,CAAC,GAAG,EAAE;AAAA;AAItD7C,YAAAA,EAAO;AAAA,cACN,oDAAoDoI,EAAE,YAAA,CAAa;AAAA,YAAA,GAEpEN,IAAiBA,EAAe,QAAQjF,EAAM,CAAC,GAAG,EAAE;AAErD;AAAA,QAAA;AAGG6F,YAAAA;AACCzB,cAAAA,GAAa,KAAKyB,CAAG;AACxB7B,gBAAAA,IAAiB,IACjB2B,IAAUU,EAAab,CAAE,EAAE,IAAIK,CAAG,GAE9BF;AACHvG,gBAAWoG,CAAE,EAAE,IAAIG,CAAO;AAAA,iBACpB;AACNxI,cAAAA,EAAO;AAAA,gBACN,mEAAmE0I,CAAG;AAAA,cAAA,GAEvEZ,IAAiBA,EAAe,QAAQjF,EAAM,CAAC,GAAG,EAAE;AACpD;AAAA,YAAA;AAAA,mBAES6F,EAAI,WAAW,GAAG;AAE5B,gBADAF,IAAUU,EAAab,CAAE,EAAE,IAAIK,CAAG,GAC9BF;AACHvG,gBAAWoG,CAAE,EAAE,IAAIG,CAAO;AAAA,iBACpB;AAGJE,cAAAA,EAAI,WAAW,SAAS,KACxBA,EAAI,WAAW,OAAO,KACtBA,EAAI,QAAQ,cAAc,KAAK,KAIhC1I,EAAO;AAAA,gBACN,kDAAkD0I,CAAG;AAAA,cACtD;AAED;AAAA,YAAA;AAAA,eAEK;AAGN1I,YAAAA,EAAO,KAAK,yCAAyC0I,CAAG,IAAI;AAC5D;AAAA,UAAA;AAAA,MACD;AAIF,UAAIV,KAAc,CAACQ;AAEflI,aAAAA,GAAK,sBAAsB,WAAW,SAAS8H,MAAM,aACrD9H,GAAK,qBAAqB,WAAW,SAAS8H,MAAM;AAEtDI,UAAAA,IAAUhC,EAAgB+B,CAAW,GACrCtG,EAAWoG,CAAE,EAAE,IAAIG,CAAO;AAAA,aACpB;AACNxI,UAAAA,EAAO;AAAA,YACN,mBAAmBoI,EAAE,YAAa,CAAA,kBAAkBC,CAAE;AAAA,UAAA,GAEvDP,IAAiBA,EAAe,QAAQjF,EAAM,CAAC,GAAG,EAAE;AACpD;AAAA,QAAA;AAIF,UAAI2F,GAAS;AACNQ,cAAAA,IAA0B9B,GAA0B,KAAKN,CAAK;AAEpEkB,QAAAA,IAAiBA,EAAe;AAAA,UAC/BjF,EAAM,CAAC;AAAA,UACPsF;AAAAA,YACCK;AAAAA,YACA5B,IAAQ,IAAIA,CAAK,KAAK;AAAA,YACtBC,KAAkB,CAACmC;AAAAA,YACnBT;AAAAA,UAAA;AAAA,QAEF;AAAA,MAAA;AAAA,IACD;AAIK,SAAA;AAAA,IACN,YAAAtG;AAAAA,IACA,gBAAA6F;AAAAA,EACD;AACD,GApL0C,4BAAA,GAsLpCsB,KAAkBzJ,gBAAAA,EAAA,OACvBK,GACAU,GACA6F,GACApG,GACAG,GACAC,MACmB;AACnB,QAAMuG,IAAU,MAAMzD,EAAS3C,GAAU,MAAM,GACzCoH,IAAiB,MAAMJ;AAAA,IAC5B1H;AAAAA,IACAuG;AAAAA,IACA8C,EAAS9C,GAAS7F,CAAQ;AAAA,IAC1BoG;AAAAA,IACA3G;AAAAA,IACAG,GAAK,sBAAsB;AAAA,IAC3BA,GAAK,qBAAqB;AAAA,IAC1BC;AAAAA,EACD;AAEIuH,EAAAA,MAAmBhB,KACtB,MAAMtB,EAAU9E,GAAUoH,CAAc;AAE1C,GAvBwB,iBAAA,GAyBXwB,IAAc3J,gBAAAA,EAAA,CAACiE,GAAcC,MAA0B;AAC/DD,MAAAA,EAAE,WAAWC,EAAE;AACX,WAAA;AAGR,WAAS0F,IAAI,GAAGA,IAAI3F,EAAE,QAAQ2F;AAC7B,QAAI3F,EAAE2F,CAAC,MAAM1F,EAAE0F,CAAC;AACR,aAAA;AAIF,SAAA;AACR,GAZ2B,gBAcdC,KAAkB7J,gBAAAA,EAAA,CAC9BiE,GACAC,MACa;AACb,QAAM4F,IAAQ,OAAO,KAAK7F,CAAC,EAAE,QACvB8F,IAAQ,OAAO,KAAK7F,CAAC,EAAE,KAAK;AAE9B,MAAA,CAACyF,EAAYG,GAAOC,CAAK;AACrB,WAAA;AAGR,aAAW,CAACC,GAAMC,CAAM,KAAK,OAAO,QAAQhG,CAAC,GAAG;AACzCiG,UAAAA,IAAShG,EAAE8F,CAAI;AAKrB,QAJI,CAACE,KAKJ,CAACP,EAAYM,EAAO,SAASC,EAAO,OAAO,KAC3C,CAACP,EAAYM,EAAO,QAAQC,EAAO,MAAM;AAElC,aAAA;AAAA,EAAA;AAIF,SAAA;AACR,GA1B+B,oBA4BlBC,KAAiBnK,gBAAAA,EAAA,CAC7BiE,GACAC,MACa;AACb,QAAMkG,IAAe,OAAO,KAAKnG,EAAE,OAAO,EAAE,KAAK,GAC3CoG,IAAe,OAAO,KAAKnG,EAAE,OAAO,EAAE,QACtCoG,IAAc,OAAO,KAAKrG,EAAE,MAAM,EAAE,KAAA,GACpCsG,IAAc,OAAO,KAAKrG,EAAE,MAAM,EAAE,KAAK;AAG9C,MAAA,CAACyF,EAAYS,GAAcC,CAAY,KACvC,CAACV,EAAYW,GAAaC,CAAW;AAE9B,WAAA;AAGR,aAAW,CAACP,GAAMC,CAAM,KAAK,OAAO,QAAQhG,EAAE,OAAO;AAChDC,QAAAA,EAAE,QAAQ8F,CAAI,MAAMC;AAChB,aAAA;AAGT,aAAW,CAACD,GAAMC,CAAM,KAAK,OAAO,QAAQhG,EAAE,MAAM;AAC/CC,QAAAA,EAAE,OAAO8F,CAAI,MAAMC;AACf,aAAA;AAIF,SAAA;AACR,GA5B8B,mBAmCjBO,KAAyBxK,gBAAAA,EAAA,OACrCK,GACAoK,GACAjK,MACmB;AACbJ,QAAAA;AAAAA,IACLC;AAAAA,IACAoK;AAAAA,IACAA;AAAAA,IACAjK;AAAAA,IACA,OAAOkK,GAASC,GAAWC,GAAUC,MAAO;AACrCC,YAAAA,IAAe,IAAIpB,EAASkB,GAAUD,CAAS,CAAC,IAEhDI,IAAMC,EAAQL,CAAS;AAC7B,UAAI,CAAC,OAAO,MAAM,EAAE,SAASI,CAAG;AAC/B,YAAI,CAACF,EAAG,qBAAqB,QAAQ,IAAIC,CAAY,GAAG;AACvD,gBAAMjC,IAAUhC,EAAgB,MAAMnD,EAASiH,CAAS,CAAC;AACzDE,YAAG,gBAAgB,IAAIhC,CAAO,GAC9BgC,EAAG,qBAAqB,QAAQ,IAAIC,GAAcjC,CAAO;AAAA,QAAA;AAAA,iBAEhDkC,MAAQ,UACd,CAACF,EAAG,qBAAqB,OAAO,IAAIC,CAAY,GAAG;AACtD,cAAMjC,IAAUhC,EAAgB,MAAMnD,EAASiH,CAAS,CAAC;AACzDE,UAAG,eAAe,IAAIhC,CAAO,GAC7BgC,EAAG,qBAAqB,OAAO,IAAIC,GAAcjC,CAAO;AAAA,MAAA;AAAA,IAG3D;AAAA,IACA,CAAA8B,MAAa,CAAC,OAAO,QAAQ,MAAM,EAAE,SAASK,EAAQL,CAAS,CAAC;AAAA,EACjE;AACD,GA9BsC,2BAgCzBM,KAAiBjL,gBAAAA,EAAA,OAC7BW,GACAH,MACmB;AACnB,aAAW0K,KAAavK,EAAI,wBAAwB,CAAA,GAAI;AAEvD,UAAMuI,IAAkB,OADC,MAAM,MAAMgC,GAAW,EAAE,QAAQ,MAAM,CAAC,GAClB,YAAA,GACzCrC,IAAUhC,EAAgBqC,CAAe;AAE/C1I,MAAE,gBAAgB,IAAIqI,CAAO,GAC7BrI,EAAE,qBAAqB,QAAQ,IAAI0K,GAAWrC,CAAO;AAAA,EAAA;AAGtD,aAAWsC,KAAYxK,EAAI,uBAAuB,CAAA,GAAI;AAErD,UAAMuI,IAAkB,OADC,MAAM,MAAMiC,GAAU,EAAE,QAAQ,MAAM,CAAC,GACjB,YAAA,GACzCtC,IAAUhC,EAAgBqC,CAAe;AAE/C1I,MAAE,eAAe,IAAIqI,CAAO,GAC5BrI,EAAE,qBAAqB,OAAO,IAAI2K,GAAUtC,CAAO;AAAA,EAAA;AAErD,GArB8B,gBAAA;AAwB9B,eAAsBuC,EACrB/K,GACAG,GACA6K,GACAC,GACgB;AACZC,MAAAA,IAA2B,IAC3BC,IAAgB;AAEpB,QAAMC,IAAqB,MAAM,KAAKjL,EAAE,kBAAkB,EAAE,KACtDkL,GAAAA,IAAoB,MAAM,KAAKlL,EAAE,iBAAiB,EAAE,KAAK,GACzDmL,IAAkB,MAAM,KAAKnL,EAAE,eAAe,EAAE,KAChDoL,GAAAA,IAAiB,MAAM,KAAKpL,EAAE,cAAc,EAAE,KAAK,GACnDqL,IACL,CAAC;AAEF,aAAW,CAACtK,GAAGC,CAAC,KAAKhB,EAAE,iBAAiB,QAAQ;AAC/CqL,MAActK,CAAC,IAAI;AAAA,MAClB,SAAS,MAAM,KAAKC,EAAE,OAAO,EAAE,KAAK;AAAA,MACpC,QAAQ,MAAM,KAAKA,EAAE,MAAM,EAAE,KAAK;AAAA,IACnC;AAGD,QAAMsK,IAGF,EAAE,SAAS,CAAA,GAAI,QAAQ,CAAA,EAAG;AAE9B,aAAW,CAACvK,GAAGC,CAAC,KAAKhB,EAAE,qBAAqB,QAAQ,QAAQ;AAC3DsL,IAAAA,EAAkB,QAAQvK,CAAC,IAAIC;AAGhC,aAAW,CAACD,GAAGC,CAAC,KAAKhB,EAAE,qBAAqB,OAAO,QAAQ;AAC1DsL,IAAAA,EAAkB,OAAOvK,CAAC,IAAIC;AAG3B,MAAA,MAAMzB,EAAcsL,CAAe,GAAG;AACzC,UAAMU,IAAwB,MAAM;AAAA;AAAA,MAChBV;AAAAA;AAGpBE,IAAAA,IAA2B,CAACpB;AAAA,MAC3B2B;AAAAA,MACAC,EAAQ,wBAAwB,EAAE,SAAS,CAAI,GAAA,QAAQ,CAAG,EAAA;AAAA,IAAA,GAE3DP,IACCD,KACA,CAAC5B,EAAY8B,GAAoBM,EAAQ,sBAAsB,CAAE,CAAA,KACjE,CAACpC,EAAY+B,GAAmBK,EAAQ,qBAAqB,CAAE,CAAA,KAC/D,CAACpC,EAAYgC,GAAiBI,EAAQ,mBAAmB,CAAA,CAAE,KAC3D,CAACpC,EAAYiC,GAAgBG,EAAQ,kBAAkB,CAAE,CAAA,KACzD,CAAClC,GAAgBgC,GAAeE,EAAQ,oBAAoB,EAAE;AAAA,EAChE;AACCP,QAAgB;AAGjB,MAAIA,GAAe;AACdD,IAAAA,KAA4BD,KAC/BjL,EAAO;AAAA,MACN;AAAA,IACD;AAGD,QAAI2L,IAAoB;AAAA;AAAA;AACxBA,IAAAA,KAAqB,+DAA+DP,EAClF,IAAI,CAAAjL,MAAK;AAAA,IAAQA,CAAC,IAAI,EACtB,KAAK,EAAE,CAAC,GAAGiL,EAAmB,SAAS,IAAI;AAAA,IAAO,EAAE;AAAA;AAAA,GACtDO,KAAqB,8DAA8DN,EACjF,IAAI,CAAAlL,MAAK;AAAA,IAAQA,CAAC,IAAI,EACtB,KAAK,EAAE,CAAC,GAAGkL,EAAkB,SAAS,IAAI;AAAA,IAAO,EAAE;AAAA;AAAA,GACrDM,KAAqB,4DAA4DL,EAC/E,IAAI,CAAAnL,MAAK;AAAA,IAAQA,CAAC,IAAI,EACtB,KAAK,EAAE,CAAC,GAAGmL,EAAgB,SAAS,IAAI;AAAA,IAAO,EAAE;AAAA;AAAA,GACnDK,KAAqB,2DAA2DJ,EAC9E,IAAI,CAAApL,MAAK;AAAA,IAAQA,CAAC,IAAI,EACtB,KAAK,EAAE,CAAC,GAAGoL,EAAe,SAAS,IAAI;AAAA,IAAO,EAAE;AAAA;AAAA,GAClDI,KAAqB;AAAA,6EAAgH,OAAO;AAAA,MAC3IH;AAAAA,IAAA,EAEC,KACA,EAAA;AAAA,MACA,CAAC,CAACtK,GAAGC,CAAC,MACL;AAAA,KAAUD,CAAC;AAAA,eAAyBC,EAAE,QACpC,IAAI,CAAAhB,MAAK;AAAA,OAAcA,CAAC,IAAI,EAC5B,KAAK,EAAE,CAAC,GACTgB,EAAE,QAAQ,SAAS,IAAI;AAAA,OAAa,EACrC;AAAA,cAAsBA,EAAE,OACtB,IAAI,CAAAhB,MAAK;AAAA,OAAcA,CAAC,IAAI,EAC5B,KAAK,EAAE,CAAC,GAAGgB,EAAE,OAAO,SAAS,IAAI;AAAA,OAAa,EAAE;AAAA;AAAA,IAAA,EAEnD,KAAK,GAAG,CAAC;AAAA;AAAA;AAAA,GACXwK,KAAqB;AAAA;AAAA,EAA8F,OAAO;AAAA,MACzHF,EAAkB;AAAA,IAAA,EAEjB,IAAI,CAAC,CAACvK,GAAGC,CAAC,MAAM,MAAQD,CAAC,OAAOC,CAAC;AAAA,CAAM,EACvC;AAAA,MACA;AAAA,IAAA,CACA;AAAA;AAAA,EAA6D,OAAO;AAAA,MACrEsK,EAAkB;AAAA,IAAA,EAEjB,IAAI,CAAC,CAACvK,GAAGC,CAAC,MAAM,MAAQD,CAAC,OAAOC,CAAC;AAAA,CAAM,EACvC,KAAK,EAAE,CAAC;AAAA;AAAA,GAEV,MAAMyK,GAAMC,GAAQb,CAAe,GAAG,EAAE,WAAW,GAAM,CAAA,GACzD,MAAMxF,EAAUwF,GAAiBW,CAAiB;AAAA,EAAA;AAEpD;AA1GsBhM,EAAAoL,GAAA;AAAApL,EAAAoL,GAAA,yBAAA;AA4GtB,MAAMe,KAAsBnM,gBAAAA,EAAA,OAAyB;AAAA,EACpD,wCAAwB,IAAI;AAAA,EAC5B,uCAAuB,IAAI;AAAA,EAC3B,qCAAqB,IAAI;AAAA,EACzB,oCAAoB,IAAI;AAAA,EACxB,sCAAsB,IAAI;AAAA,EAC1B,sBAAsB;AAAA,IACrB,6BAAa,IAAI;AAAA,IACjB,4BAAY,IAAI;AAAA,EAAA;AAElB,IAV4B,qBAAA,GAafoM,KAAqBpM,gBAAAA,EAAA,OACjCK,GACA,EAAE,OAAAO,GAAO,SAAAgG,GAAS,KAAAjG,GAAK,iBAAA0L,QACJ;AACnB,QAAM7L,IAAI2L,GAAoB;AAE9B,MAAA,MAAMlB,GAAetK,GAAKH,CAAC,GAC3B,MAAMgK,GAAuBnK,GAAQuG,GAASpG,CAAC,GAC/C,MAAMJ;AAAAA,IACLC;AAAAA,IACAuG;AAAAA,IACAA;AAAAA,IACApG;AAAAA,IACAiJ;AAAAA,IACA,CAAA5I,MAAQmK,EAAQnK,CAAI,MAAM;AAAA,IAC1BF;AAAAA,IACAC;AAAAA,EAAA,GAGGyL,GAAiB,wBAAwB,QAAW;AACjDC,UAAAA,IAAWD,EAAgB,oBAAoB;AACrD,YAAQC,GAAU;AAAA,MACjB,KAAK,WAAW;AACT9G,cAAAA;AAAAA,UACLxE,EAAQ4F,GAAS,UAAU;AAAA,UAC3ByF;AAAAA,UACA7L,EAAE;AAAA,QACH;AACA;AAAA,MAAA;AAAA,MAED,KAAK,UAAU;AACRmG,cAAAA;AAAAA,UACLtG;AAAAA,UACAuG;AAAAA,UACAhG,EAAM;AAAA,UACNyL;AAAAA,UACA7L,EAAE;AAAA,QACH;AACA;AAAA,MAAA;AAAA,MAED;AACCsF,QAAAA,GAAgBwG,GAAU,UAAU;AAAA,IAAA;AAAA,EACtC;AAGG3L,IAAI,gBACP,MAAMyK;AAAA,IACL/K;AAAAA,IACAG;AAAAA,IACAG,EAAI;AAAA,IACJA,EAAI;AAAA,EACL;AAEF,GArDkC,oBAAA,GAuDrB4L,KAAuBvM,gBAAAA,EAAA,CACnCK,GACAkJ,GACA5I,MAEQ,OAAO6L,GAAMC,MAAS;AAC7B,QAAMC,IAAW,MAAMD,EAAK,GACtBtF,IAAU,MAAMuF,EAAS,QAEzB,EAAE,gBAAAvE,EAAmB,IAAAmB;AAAA,IAC1BjJ;AAAAA,IACA8G;AAAAA,IACAoC;AAAAA,IACA5I;AAAAA,EACD;AAEwB,SAAA,IAAI,SAASwH,GAAgB;AAAA,IACpD,QAAQuE,EAAS;AAAA,IACjB,YAAYA,EAAS;AAAA,IACrB,SAASA,EAAS;AAAA,EAAA,CAClB;AAEF,GAtBmC,sBAAA,GA4BvBC,KAA0B3M,gBAAAA,EAAA,CACtCK,GACAkJ,GACA7G,GACA/B,MAEQ,OAAO6L,GAAMC,MAAS;AAC7B,QAAMC,IAAW,MAAMD,KACjBtF,IAAU,MAAMuF,EAAS,KAAK,GAE9B,EAAE,gBAAAvE,GAAgB,YAAA7F,EAAe,IAAAgH;AAAA,IACtCjJ;AAAAA,IACA8G;AAAAA,IACAoC;AAAAA,IACA5I;AAAAA,EACD;AAEwB,SAAA,IAAI,SAASwH,GAAgB;AAAA,IACpD,QAAQuE,EAAS;AAAA,IACjB,YAAYA,EAAS;AAAA,IACrB,SAASlK,GAAakK,EAAS,SAASpK,GAAYI,CAAmB;AAAA,EAAA,CACvE;AAEF,GAvBsC,yBAAA,GA0BjCkK,KAA4B,+CAC5BC,IAAoC,KAAKD,EAAyB,IAElEE,KAA8B9M,gBAAAA,EAAA,OACnCK,GACAM,GACA2D,GACAyI,MACqB;AACjBC,MAAAA,IAAe,IACfC,IAA2B;AAE3BtM,MAAAA,EAAI,gBAAgBA,EAAI,cAAc;AACzC,QAAIuM,IAA+B,CAAE,MAAMnN,EAAcY,EAAI,YAAY;AAEzE,QAAI,CAACuM;AACA,UAAA;AACH,cAAMC,IAA6B,MAAM;AAAA;AAAA,UACrBxM,EAAI;AAAA;AAGxB,mBAAWyM,KAAiBzM,EAAI;AAC/B,cACC,CAAC,OAAO;AAAA,YACPwM,EAAa,qBAAqB;AAAA,YAClCC;AAAAA,UAAA,GAEA;AACDF,gBAA+B;AAC/B;AAAA,UAAA;AAAA,eAGM/M,GAAK;AACbE,QAAAA,EAAO;AAAA,UACN,qCAAqCM,EAAI,YAAY;AAAA,GAAkCR,CAAG;AAAA,QAAA,GAE3F+M,IAA+B;AAAA,MAAA;AAIjC,QAAIA,GAA8B;AACjC,YAAM1M,IAAI2L,GAAoB;AAIxB,YAAA3B,GAAuBnK,GAAQ0M,GAAWvM,CAAC,GACjD,MAAMyK,GAAetK,GAAKH,CAAC,GAC3B,MAAM4K;AAAA,QACL/K;AAAAA,QACAG;AAAAA,QACAG,EAAI;AAAA,QACJ;AAAA;AAAA,MACD;AAAA,IAAA;AAAA,EACD;AAGD,SACCA,EAAI,gBACJA,EAAI,gBACH,MAAMZ,EAAcY,EAAI,YAAY,KAErCqM,IAAe,yCAAyCrM,EAAI,YAAY,KACxEsM,IAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAkBjBtM,EAAI,gBAAgBA,EAAI,gBAGlCN,EAAO;AAAA,IACN,0BAA0BM,EAAI,YAAY;AAAA,EAAA,GAIrC;AAAA;AAAA;AAAA,WAIN2D,MAA2B,SACxB,4BACA,sBACJ;AAAA,EACC0I,CAAY;AAAA;AAAA;AAAA;AAAA;AAAA,GAKXC,CAAwB;AAAA;AAAA,2BAGzB3I,MAA2B,SACxB,kDAAkD,KAAK;AAAA,IACvDA;AAAAA,EACA,CAAA,KAAK,KAAK,UAAU3D,CAAG,CAAC,MACxB,+CAA+C,KAAK,UAAUA,CAAG,CAAC,GACtE;AAAA;AAAA;AAGD,GA7GoC,6BAAA,GAgHvB0M,KAA0BrN,gBAAAA,EAAA,CACtCK,GACAM,GACA0L,GACAU,OAEO;AAAA,EACN,MAAM;AAAA,EACN,UAAUO,GAAI;AACb,QAAIA,MAAOV;AACHC,aAAAA;AAAAA,EAGT;AAAA,EACA,MAAM,KAAKS,GAAIC,GAAU;AACxB,YAAQD,GAAI;AAAA,MACX,KAAKT;AACJ,eAAO,MAAMC;AAAAA,UACZzM;AAAAA,UACAM;AAAAA,UACA0L;AAAAA,UACAU;AAAAA,QACD;AAAA,MACD;AACC;AAAA,IAAA;AAAA,EACF;AAEF,IA3BsC,yBA8B1B,GAAAS,KAAoBxN,gBAAAA,EAAA,CAChCY,GACAD,GACA0L,MAEC,OAAO,EAAE,KAAAoB,GAAK,QAAApN,QAAa;AACvBM,IAAI,gBACP,MAAMyL,GAAmB/L,GAAQ;AAAA,IAChC,OAAAO;AAAAA,IACA,SAAS8M,EAAcD,CAAG;AAAA,IAC1B,KAAA9M;AAAAA,IACA,iBAAA0L;AAAAA,EAAA,CACA;AAEH,GAdgC,sBAqBpBsB,KAAsB3N,gBAAAA,EAAA,CAClCY,GACAD,GACA0L,MAGO,OAAO,EAAE,QAAAhM,GAAQ,eAAAuN,GAAe,QAAApK,GAAQ,cAAAqK,QAAmB;AAGjE,MAFAjN,EAAM,SAAS4C,GAEX7C,EAAI,kBAAkB;AACzB,UAAMoM,IAAYW,EAAclK,EAAO,SAAS,GAC1CsK,IAAST;AAAA,MACdhN;AAAAA,MACAM;AAAAA,MACA0L;AAAAA,MACAU;AAAAA,IACD;AACAc,MAAa,EAAE,MAAM,EAAE,SAAS,CAACC,CAAM,EAAE,EAAA,CAAG,GAE5CF,EAAc;AAAA,MACb,OAAO;AAAA,MACP,YAAY;AAAA,IAAA,CACZ;AAAA,EAAA;AAGEhN,EAAAA,EAAM,kBACTiN,EAAa;AAAA,IACZ,cAAc;AAAA,MACb;AAAA,QACC,MAAM;AAAA,QACN,OAAO;AAAA,UACN,oBAAoBL;AAAA,YACnB5M;AAAAA,YACAD;AAAAA,YACA0L;AAAAA,UAAA;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD,CACA;AAEH,GAzCkC,qBAAA;"}